==== package.json ====
{
  "name": "contact-center-server",
  "version": "0.1.0",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "node --watch src/index.js",
    "start": "node src/index.js",
    "provision": "node ./scripts/provision.mjs",
    "cleanup:conversations": "node ./scripts/cleanup-conversations.mjs"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.6.1",
    "express": "^4.21.2",
    "express-rate-limit": "^8.0.1",
    "jsonwebtoken": "^9.0.2",
    "shared": "file:../../packages/shared",
    "socket.io": "^4.8.1",
    "twilio": "^5.8.0"
  }
}
==== /package.json ====

==== scripts\cleanup-conversations.mjs ====
// scripts/cleanup-conversations.mjs
import 'dotenv/config';
import Twilio from 'twilio';

const {
  TWILIO_ACCOUNT_SID,
  TWILIO_AUTH_TOKEN,
  TWILIO_CONVERSATIONS_SERVICE_SID,
  TWILIO_REGION,
  TWILIO_EDGE,
} = process.env;

if (!TWILIO_ACCOUNT_SID || !TWILIO_AUTH_TOKEN || !TWILIO_CONVERSATIONS_SERVICE_SID) {
  console.error('Missing TWILIO_ACCOUNT_SID/TWILIO_AUTH_TOKEN/TWILIO_CONVERSATIONS_SERVICE_SID');
  process.exit(1);
}

const client = Twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, {
  autoRetry: true,
  maxRetries: 3,
  keepAlive: true,
  region: TWILIO_REGION || undefined,
  edge: TWILIO_EDGE || undefined,
});

const args = new Set(process.argv.slice(2));
const DRY = args.has('--dry');      // solo listar
const HARD = args.has('--hard');     // también remover participantes
const DELETE = args.has('--delete'); // borrar conversación (requiere estado closed)

const service = client.conversations.v1.services(TWILIO_CONVERSATIONS_SERVICE_SID);
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

async function listAllConversations(pageSize = 100) {
  const out = [];
  let page = await service.conversations.page({ pageSize });
  while (page) {
    out.push(...page.instances);
    if (!page.hasNextPage) break;
    page = await page.nextPage();
  }
  return out;
}

async function removeAllParticipants(conversationSid) {
  const parts = await service.conversations(conversationSid).participants.list({ limit: 200 });
  let removed = 0;
  for (const p of parts) {
    try {
      await service.conversations(conversationSid).participants(p.sid).remove();
      removed++;
    } catch (e) {
      console.warn(`[WARN] remove participant ${p.sid} failed:`, e?.message || e);
    }
    await sleep(50);
  }
  return removed;
}

async function closeOne(convo) {
  const sid = convo.sid;
  const uniqueName = convo.uniqueName;
  const prev = String(convo.state || convo.status || '').toLowerCase();

  if (DRY) return { sid, uniqueName, prev, now: prev, partsRemoved: 0, deleted: false, skipped: true };

  // Intenta cierre directo
  if (prev !== 'closed') {
    try {
      await service.conversations(sid).update({ state: 'closed' });
    } catch (e) {
      // Fallback con timers=PT0S si el cierre directo falla
      console.warn(`[WARN] state=closed failed for ${sid}: ${e?.message || e}. Falling back to timers.`);
      await service.conversations(sid).update({
        'timers.inactive': 'PT0S',
        'timers.closed': 'PT0S',
      });
    }
  }

  let partsRemoved = 0;
  if (HARD) {
    partsRemoved = await removeAllParticipants(sid);
  }

  let deleted = false;
  if (DELETE) {
    try { await service.conversations(sid).remove(); deleted = true; }
    catch (e) { console.warn(`[WARN] delete ${sid} failed:`, e?.message || e); }
  }

  return { sid, uniqueName, prev, now: 'closed', partsRemoved, deleted, skipped: false };
}

async function run() {
  const all = await listAllConversations(100);
  console.log(`Found ${all.length} conversations`);

  const results = [];
  let closed = 0, skipped = 0, totalPartsRemoved = 0, totalDeleted = 0;

  // Concurrency
  const MAX = 10;
  for (let i = 0; i < all.length; i += MAX) {
    const batch = all.slice(i, i + MAX);
    const r = await Promise.all(batch.map(closeOne));
    for (const item of r) {
      results.push(item);
      if (item.skipped) { skipped++; continue; }
      closed++;
      totalPartsRemoved += item.partsRemoved;
      if (item.deleted) totalDeleted++;
    }
  }

  console.table(results.map(x => ({
    sid: x.sid,
    uniqueName: x.uniqueName || '',
    prev: x.prev,
    now: x.now,
    partsRemoved: x.partsRemoved,
    deleted: x.deleted
  })));

  console.log(`Closed: ${closed}, Skipped(dry-run): ${skipped}, Participants removed: ${totalPartsRemoved}, Deleted: ${totalDeleted}`);
}

run().catch((e) => { console.error(e); process.exit(1); });

==== /scripts\cleanup-conversations.mjs ====

==== scripts\provision.mjs ====
// scripts/provision.mjs
import 'dotenv/config';
import Twilio from 'twilio';

const {
  TWILIO_ACCOUNT_SID,
  TWILIO_AUTH_TOKEN,
  PUBLIC_BASE_URL,
  TR_WORKSPACE_SID,
  TR_WORKFLOW_SID,
} = process.env;

if (!TWILIO_ACCOUNT_SID || !TWILIO_AUTH_TOKEN) {
  console.error('Missing TWILIO_ACCOUNT_SID/TWILIO_AUTH_TOKEN');
  process.exit(1);
}

const client = Twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);

function trimBase(url) {
  return (url || '').trim().replace(/\/+$/, '');
}

async function fetchWorkspace(wsSid) {
  if (!wsSid) throw new Error('TR_WORKSPACE_SID is required to run provision');
  return client.taskrouter.v1.workspaces(wsSid).fetch();
}

async function listWorkflows(wsSid) {
  return client.taskrouter.v1.workspaces(wsSid).workflows.list({ limit: 50 });
}

async function fetchWorkflow(wsSid, wfSid) {
  return client.taskrouter.v1.workspaces(wsSid).workflows(wfSid).fetch();
}

function parseConfig(cfg) {
  try { return typeof cfg === 'string' ? JSON.parse(cfg) : (cfg || {}); }
  catch { return {}; }
}

function stringifyConfig(cfg) {
  return JSON.stringify(cfg);
}

async function resolveWorkflowToUpdate(wsSid) {
  // 1) Si el .env trae TR_WORKFLOW_SID, usa ese
  if (TR_WORKFLOW_SID) {
    try {
      const wf = await fetchWorkflow(wsSid, TR_WORKFLOW_SID);
      return wf;
    } catch (e) {
      console.warn(`[provision] Cannot fetch TR_WORKFLOW_SID=${TR_WORKFLOW_SID}. Will try by name…`, e?.message || e);
    }
  }

  // 2) Buscar por nombre común
  const all = await listWorkflows(wsSid);
  let wf = all.find(w => (w.friendlyName || '').toLowerCase() === 'default fifo workflow')
         || all.find(w => (w.friendlyName || '').toLowerCase() === 'default workflow');

  // 3) Último recurso: el primero de la lista
  if (!wf && all.length) wf = all[0];

  if (!wf) throw new Error('No Workflow found in this Workspace');
  return wf;
}

async function ensureAssignmentCallback(wsSid, wfSid, url, config) {
  const ws = client.taskrouter.v1.workspaces(wsSid);
  return ws.workflows(wfSid).update({
    assignmentCallbackUrl: url,
    configuration: stringifyConfig(config),
  });
}

function buildDirectRoutingConfig(currentConfig, queueSid) {
  // Clona config actual y escribe filtro directo por selected_contact_uri
  const cfg = parseConfig(currentConfig);
  const filters = Array.isArray(cfg?.task_routing?.filters) ? [...cfg.task_routing.filters] : [];

  // Sobrescribe/inyecta un filtro claro y de alta prioridad
  const directFilter = {
    filter_friendly_name: 'DirectToSelectedContact',
    expression: 'task.selected_contact_uri != null',
    targets: [{
      queue: queueSid,
      // Esta expresión se evalúa contra atributos del worker (no se antepone "worker.")
      expression: 'contact_uri == task.selected_contact_uri',
      priority: 100
    }]
  };

  // Elimina versiones previas del mismo filtro si existieran
  const nextFilters = filters.filter(f => (f.filter_friendly_name || '').toLowerCase() !== 'directtoselectedcontact');
  nextFilters.unshift(directFilter);

  const default_filter = cfg?.task_routing?.default_filter?.queue
    ? cfg.task_routing.default_filter
    : { queue: queueSid };

  return {
    task_routing: {
      filters: nextFilters,
      default_filter
    }
  };
}

async function ensureTaskChannel(wsSid, uniqueName = 'chat', friendlyName = 'Chat') {
  const list = await client.taskrouter.v1.workspaces(wsSid).taskChannels.list({ limit: 50 });
  const found = list.find(c => c.uniqueName === uniqueName);
  if (found) return found;
  return client.taskrouter.v1.workspaces(wsSid).taskChannels.create({
    uniqueName,
    friendlyName,
    channelOptimizedRouting: true
  });
}

async function ensureTwiMLApp(name, voiceUrl) {
  const apps = await client.applications.list({ limit: 50 });
  const found = apps.find(a => a.friendlyName === name);
  if (found) return found;
  return client.applications.create({ friendlyName: name, voiceUrl, voiceMethod: 'POST' });
}

async function main() {
  if (!TR_WORKSPACE_SID) throw new Error('TR_WORKSPACE_SID is required');
  const base = trimBase(PUBLIC_BASE_URL || 'https://example.ngrok.app');
  const voiceUrl = `${base}/api/voice/outbound`;
  const assignmentCallbackUrl = `${base}/api/taskrouter/assignment`;

  // (Opcional) Asegura TwiML App (solo para voz saliente)
  const app = await ensureTwiMLApp('ContactCenter Web Outbound', voiceUrl);

  // Workspace & Workflow a actualizar (el que REALMENTE usas)
  await fetchWorkspace(TR_WORKSPACE_SID);
  const wf = await resolveWorkflowToUpdate(TR_WORKSPACE_SID);

  // Descubre la cola que ya usa tu Workflow (para no romper ruteo)
  const cfg = parseConfig(wf.configuration);
  const queueSid =
    cfg?.task_routing?.default_filter?.queue ||
    cfg?.task_routing?.filters?.[0]?.targets?.[0]?.queue ||
    null;

  if (!queueSid) {
    throw new Error('Cannot determine a TaskQueue SID from current Workflow configuration. Set a default_filter.queue first.');
  }

  // Inyecta filtro "DirectToSelectedContact" y actualiza AssignmentCallbackUrl
  const newConfig = buildDirectRoutingConfig(cfg, queueSid);
  const updated = await ensureAssignmentCallback(TR_WORKSPACE_SID, wf.sid, assignmentCallbackUrl, newConfig);

  // (Opcional) Asegura el canal 'chat'
  const chatCh = await ensureTaskChannel(TR_WORKSPACE_SID, 'chat', 'Chat');

  console.log('\n=== Provisioned / Updated ===');
  console.log('TWIML_APP_SID=', app.sid);
  console.log('TR_WORKSPACE_SID=', TR_WORKSPACE_SID);
  console.log('TR_WORKFLOW_SID=', updated.sid, `(name="${updated.friendlyName}")`);
  console.log('ASSIGNMENT_CALLBACK_URL=', updated.assignmentCallbackUrl);
  console.log('TR_CHAT_CHANNEL_SID=', chatCh.sid);
}

main().catch(e => { console.error(e); process.exit(1); });

==== /scripts\provision.mjs ====

==== src\controllers\crm.js ====
import {
  vehicleById,
  customerById,
  vehicleByPlate,
  vehicleByVin,
  appointments,
  createAppointment,
  finance,
  payLink,
  logInteraction
} from '../services/crm.js';

export async function getVehicleById(req, res) {
  try { res.json(await vehicleById(req.params.id)); }
  catch { res.status(500).json({ error: 'crm error' }); }
}

export async function getCustomerById(req, res) {
  try { res.json(await customerById(req.params.id)); }
  catch { res.status(500).json({ error: 'crm error' }); }
}

export async function getVehicleByPlate(req, res) {
  try { res.json(await vehicleByPlate(req.params.plate)); }
  catch { res.status(500).json({ error: 'crm error' }); }
}

export async function getVehicleByVin(req, res) {
  try { res.json(await vehicleByVin(req.params.vin)); }
  catch { res.status(500).json({ error: 'crm error' }); }
}

export async function getAppointments(req, res) {
  try { res.json(await appointments(req.params.vehicleId)); }
  catch { res.status(500).json({ error: 'crm error' }); }
}

export async function postAppointment(req, res) {
  try { res.json(await createAppointment(req.body)); }
  catch { res.status(500).json({ error: 'crm error' }); }
}

export async function getFinance(req, res) {
  try {
    const otpVerified = String(req.query.otpVerified || 'false') === 'true';
    res.json(await finance(req.params.customerId, otpVerified));
  } catch { res.status(500).json({ error: 'crm error' }); }
}

export async function postPayLink(req, res) {
  try { res.json(await payLink(req.body.customerId)); }
  catch { res.status(500).json({ error: 'crm error' }); }
}

export async function postInteraction(req, res) {
  try { res.json(await logInteraction(req.body)); }
  catch { res.status(500).json({ error: 'crm error' }); }
}

==== /src\controllers\crm.js ====

==== src\controllers\health.js ====
export function getHealth(_req, res) {
  res.json({ ok: true });
}

==== /src\controllers\health.js ====

==== src\controllers\ivr.js ====
import {
  findVehicleByVin,
  findVehicleByPlate,
  findCustomerByAni,
  findVehicleById,
  findCustomerById,
  getAppointments,
  createAppointment,
  getRecallsByVin,
  getFinance,
  createPayLink
} from '../services/ivr.js';

export async function lookup(req, res) {
  try {
    const { From, plate, vin } = req.body || {};
    let customer = null, vehicle = null;

    if (vin) {
      vehicle = await findVehicleByVin(vin);
    } else if (plate) {
      vehicle = await findVehicleByPlate(plate);
    }

    if (!vehicle && From) {
      customer = await findCustomerByAni(From);
      if (customer?.defaultVehicleId) {
        try {
          vehicle = await findVehicleById(customer.defaultVehicleId);
        } catch {}
      }
    }

    if (vehicle && !customer && vehicle?.customerId) {
      customer = await findCustomerById(vehicle.customerId);
    }

    res.json({
      customerId: customer?._id || null,
      name: customer?.name || null,
      vehicleId: vehicle?._id || null,
      vin: vehicle?.vin || null,
      plate: vehicle?.plate || null,
      tier: customer?.tier || 'Standard'
    });
  } catch {
    res.status(500).json({ error: 'lookup failed' });
  }
}

export async function serviceStatus(req, res) {
  try {
    const { vehicleId } = req.body || {};
    if (!vehicleId) return res.status(400).json({ error: 'missing vehicleId' });
    const appts = await getAppointments(vehicleId);
    const last = appts?.[0] || null;
    const say = last
      ? `Your last appointment is ${new Date(last.datetime).toLocaleString()}. Status: ${last.status}.`
      : `No recent appointments found.`;
    res.json({ appointment: last, say });
  } catch {
    res.status(500).json({ error: 'status failed' });
  }
}

export async function scheduleService(req, res) {
  try {
    const { vehicleId, preferDate, serviceType } = req.body || {};
    if (!vehicleId) return res.status(400).json({ error: 'missing vehicleId' });
    const dt = preferDate ? new Date(preferDate) : new Date(Date.now() + 2 * 24 * 60 * 60 * 1000);
    dt.setHours(10, 30, 0, 0);
    const appt = await createAppointment({ vehicleId, datetime: dt, serviceType: serviceType || 'maintenance' });
    res.json({ appointment: appt, say: `Your appointment is set for ${dt.toLocaleString()}.` });
  } catch {
    res.status(500).json({ error: 'schedule failed' });
  }
}

export async function checkRecalls(req, res) {
  try {
    const { vin } = req.body || {};
    if (!vin) return res.status(400).json({ error: 'missing vin' });
    const list = await getRecallsByVin(vin);
    const say = !list.length
      ? 'There are no open recalls for your vehicle.'
      : `We found ${list.length} open recall${list.length>1?'s':''}.`;
    res.json({ recalls: list, say });
  } catch {
    res.status(500).json({ error: 'recalls failed' });
  }
}

export async function financeBalance(req, res) {
  try {
    const { customerId, otpCode } = req.body || {};
    if (!customerId) return res.status(400).json({ error: 'missing customerId' });
    const otpVerified = !!String(otpCode || '').match(/^\d{4,}$/);
    const f = await getFinance(customerId, otpVerified);
    const say = otpVerified
      ? `Your balance is ${typeof f.balance === 'number' ? f.balance : 'not available'}.`
      : `Verification required to reveal the balance.`;
    res.json({ finance: f, otpVerified, say });
  } catch {
    res.status(500).json({ error: 'finance failed' });
  }
}

export async function financePaylink(req, res) {
  try {
    const { customerId } = req.body || {};
    if (!customerId) return res.status(400).json({ error: 'missing customerId' });
    const r = await createPayLink(customerId);
    res.json({ ok: true, url: r.url });
  } catch {
    res.status(500).json({ error: 'paylink failed' });
  }
}

==== /src\controllers\ivr.js ====

==== src\controllers\taskrouter.js ====
﻿﻿// TwilioContactCenter/apps/server/src/controllers/taskrouter.js
import { requireAuth } from 'shared/auth';
import {
  listActivities,
  listWorkerReservations,
  fetchTask,
  updateTask,
  listWorkers,
  listWorkersWithRetry,
  pushEvent,
  recentEvents,
  axios,
  env
} from '../services/taskrouter.js';
import { rest } from '../twilio.js'; // REST client for TaskRouter ops

/* ---------------------------
 * Helpers
 * --------------------------- */

// Normalize to a Twilio Client "contact_uri"
function toContactUri(raw) {
  const val = String(raw || '').trim();
  if (!val) return '';
  if (val.startsWith('client:')) return val;
  if (val.startsWith('agent:')) return `client:${val}`;
  return `client:agent:${val}`;
}

function safeJson(x) {
  try { return x ? JSON.parse(x) : {}; } catch { return {}; }
}

function safeParseJson(str) {
  try { return JSON.parse(str || '{}'); } catch { return {}; }
}

/* ---------------------------
 * Assignment Callback
 * ---------------------------
 * Uses the TaskRouter "conference" instruction with **camelCase**
 * participant/conference parameters (per Twilio docs).
 * - Removes deprecated/invalid fields (post_work_activity_sid, end_conference_on_customer_exit, snake_case keys)
 * - Adds optional status callbacks for better observability
 */
export function assignment(req, res) {
  try {
    const taskSid = String(req.body.TaskSid || '').trim();

    const channelName = String(req.body.TaskChannelUniqueName || '').toLowerCase();
    const attrs = safeJson(req.body.TaskAttributes);
    const workerAttrs = safeJson(req.body.WorkerAttributes);

    // Prefer an explicit selected_contact_uri (e.g., set when agent joined a chat),
    // fall back to Worker's attributes.contact_uri
    const selected = String(attrs.selected_contact_uri || '').trim();
    const workerContact = String(workerAttrs.contact_uri || '').trim();
    const dialTarget = toContactUri(selected || workerContact);

    const isChat =
      channelName === 'chat' ||
      String(attrs.channel || '').toLowerCase() === 'chat' ||
      !!attrs.conversationSid;

    if (isChat) {
      return res.status(200).json({ instruction: 'accept' });
    }

    if (!env.callerId) {
      return res.status(200).json({ instruction: 'reject', reason: 'missing callerId' });
    }

    if (!dialTarget) {
      // No agent contact: reject so TaskRouter offers the reservation to the next eligible Worker
      return res.status(200).json({ instruction: 'reject', reason: 'no contact_uri' });
    }

    // We keep the conference name aligned with the TaskSid for easier tracing
    const conferenceName = taskSid || `task-${Date.now()}`;

    // ✅ Correct, doc-accurate conference payload (camelCase keys)
    const payload = {
      instruction: 'conference',
      from: env.callerId,          // Twilio-verified caller ID or owned number
      to: dialTarget,              // e.g. "client:agent:demo-agent-1"
      timeout: 18,                 // quick requeue if agent doesn't pick up

      // Participant/Conference params (apply to the agent leg)
      startConferenceOnEnter: true,
      endConferenceOnExit: false,
      beep: 'onEnter',
      // Optional: queue/hold music while waiting (if you want it)
      ...(env.holdMusicUrl ? { waitUrl: env.holdMusicUrl } : {}),

      // Agent call status callbacks (progress of the agent leg)
      ...(env.publicBaseUrl ? {
        statusCallback: `${env.publicBaseUrl}/api/voice/agent-call-events`,
        statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed']
      } : {}),

      // Conference lifecycle callbacks (start/end/join/leave/hold/mute)
      ...(env.publicBaseUrl ? {
        conferenceStatusCallback: `${env.publicBaseUrl}/api/voice/conference-events`,
        conferenceStatusCallbackEvent: ['start', 'end', 'join', 'leave', 'mute', 'hold']
      } : {})
    };

    return res.status(200).json(payload);
  } catch {
    return res.status(200).json({ instruction: 'reject', reason: 'assignment error' });
  }
}

/* ---------------------------
 * Events Webhook (TaskRouter)
 * ---------------------------
 * - Push presence updates to Socket.IO
 * - Auto-reject reservations lacking a dialable contact or availability
 */
export async function events(req, res) {
  console.log('TR event', req.body.EventType, req.body.TaskSid || '', req.body.ReservationSid || '');

  // Presence update
  if (req.body.EventType === 'worker.activity.update') {
    const presenceData = await listWorkers();
    const formatted = presenceData.map(w => {
      let contact = null;
      try { contact = JSON.parse(w.attributes || '{}').contact_uri || null; } catch {}
      return {
        workerSid: w.sid,
        friendlyName: w.friendlyName,
        activitySid: w.activitySid,
        activityName: w.activityName,
        available: !!w.available,
        contactUri: contact
      };
    });
    req.app.get('io')?.emit('presence_update', { data: formatted });
  }

  // Guard: reject reservation if the agent cannot be dialed or is not truly available
  if (req.body.EventType === 'reservation.created') {
    try {
      const workspaceSid = env.workspaceSid;
      const workerSid = req.body.WorkerSid;
      const reservationSid = req.body.ReservationSid;

      const workerAttrs = safeJson(req.body.WorkerAttributes);
      const contactUriRaw = workerAttrs.contact_uri || null;
      const contactUri = toContactUri(contactUriRaw);

      // Some accounts send this flag as string
      const availableFlag = String(req.body.WorkerActivityAvailable ?? '').toLowerCase();
      const available = availableFlag === 'true' || req.body.WorkerActivityAvailable === true;

      if (!contactUri || !available) {
        await rest.taskrouter.v1
          .workspaces(workspaceSid)
          .workers(workerSid)
          .reservations(reservationSid)
          .update({ reservationStatus: 'rejected' });

        pushEvent('RESERVATION_REJECTED_AUTOGUARD', {
          workerSid,
          reservationSid,
          reason: !contactUri ? 'no_contact_uri' : 'not_available'
        });
      }
    } catch (e) {
      console.warn('[reservation.guard] skipped', e?.message || e);
    }
  }

  res.sendStatus(200);
}

/* ---------------------------
 * Activities list
 * --------------------------- */
export async function activities(_req, res) {
  try {
    const list = await listActivities();
    res.json(list.map(a => ({ sid: a.sid, name: a.friendlyName, available: a.available })));
  } catch {
    res.status(500).json({ error: 'cannot fetch activities' });
  }
}

/* ---------------------------
 * My Tasks (for the Agent)
 * --------------------------- */
export async function myTasks(req, res) {
  try {
    const { workerSid } = req.claims;
    if (!workerSid) return res.status(400).json({ error: 'missing workerSid in claims' });

    const statuses = (req.query.statuses || 'wrapping,assigned,reserved')
      .split(',').map(s => s.trim().toLowerCase());

    const reservations = await listWorkerReservations(workerSid);
    const uniqueTaskSids = [...new Set(reservations.map(r => r.taskSid).filter(Boolean))];

    const fetchedTasks = await Promise.all(
      uniqueTaskSids.map(taskSid => fetchTask(taskSid).catch(() => null))
    );

    const tasks = fetchedTasks
      .filter(t => t && statuses.includes(String(t.assignmentStatus).toLowerCase()))
      .map(t => ({
        sid: t.sid,
        assignmentStatus: t.assignmentStatus,
        age: t.age,
        reason: t.reason || null,
        attributes: safeParseJson(t.attributes),
      }));

    const resvByTask = {};
    for (const r of reservations) {
      if (!resvByTask[r.taskSid]) resvByTask[r.taskSid] = [];
      resvByTask[r.taskSid].push({
        sid: r.sid,
        reservationStatus: r.reservationStatus,
        dateCreated: r.dateCreated,
      });
    }
    const enriched = tasks.map(t => ({ ...t, reservations: resvByTask[t.sid] || [] }));
    return res.json(enriched);
  } catch (e) {
    console.error('[MY_TASKS] error:', e);
    return res.status(500).json({ error: 'cannot list my tasks' });
  }
}

/* ---------------------------
 * Force WRAPPING (chat-centric)
 * --------------------------- */
export async function wrapTask(req, res) {
  try {
    const { taskSid } = req.params;
    const { reason = 'Wrap from Agent UI', disposition } = req.body || {};
    if (!taskSid) return res.status(400).json({ error: 'missing taskSid' });

    const task = await fetchTask(taskSid);
    const status = String(task.assignmentStatus).toLowerCase();

    let attrs = {};
    try { attrs = JSON.parse(task.attributes || '{}'); } catch {}
    if (disposition) attrs.disposition = disposition;
    if (reason) attrs.wrapup_reason = reason;

    if (status === 'wrapping') {
      if (disposition || reason) {
        await updateTask(taskSid, { attributes: JSON.stringify(attrs) });
      }
      pushEvent('TASK_WRAPPING', { taskSid, reason, disposition });
      return res.json({ ok: true, taskSid, assignmentStatus: 'wrapping' });
    }

    if (status === 'assigned') {
      const updated = await updateTask(taskSid, {
        assignmentStatus: 'wrapping',
        reason: String(reason || 'Wrap from Agent UI').slice(0, 200),
        attributes: JSON.stringify(attrs),
      });
      pushEvent('TASK_WRAPPING', { taskSid: updated.sid, reason, disposition });
      return res.json({ ok: true, taskSid: updated.sid, assignmentStatus: 'wrapping' });
    }

    return res.status(400).json({
      error: `cannot wrap task in status ${task.assignmentStatus}`,
      assignmentStatus: task.assignmentStatus
    });
  } catch (e) {
    console.error('[WRAP_TASK] error:', e);
    return res.status(500).json({ error: 'cannot wrap task' });
  }
}

/* ---------------------------
 * Complete Task
 * --------------------------- */
export async function completeTask(req, res) {
  try {
    const { taskSid } = req.params;
    const { reason, disposition, autoWrap } = req.body || {};
    if (!taskSid) return res.status(400).json({ error: 'missing taskSid' });

    let task = await fetchTask(taskSid);
    let status = String(task.assignmentStatus).toLowerCase();

    if (autoWrap && status === 'assigned') {
      let attrs = {};
      try { attrs = JSON.parse(task.attributes || '{}'); } catch {}
      if (disposition) attrs.disposition = disposition;
      if (reason) attrs.wrapup_reason = reason;
      await updateTask(taskSid, {
        assignmentStatus: 'wrapping',
        reason: String(reason || 'Wrap before complete').slice(0, 200),
        attributes: JSON.stringify(attrs),
      });
      task = await fetchTask(taskSid);
      status = String(task.assignmentStatus).toLowerCase();
    }

    if (status !== 'wrapping') {
      return res.status(400).json({ error: 'task is not in wrapping', assignmentStatus: task.assignmentStatus });
    }

    let attrs = {};
    try { attrs = JSON.parse(task.attributes || '{}'); } catch {}
    if (disposition) attrs.disposition = disposition;
    if (reason) attrs.wrapup_reason = reason;

    const updated = await updateTask(taskSid, {
      assignmentStatus: 'completed',
      reason: reason ? String(reason).slice(0, 200) : 'Finished from Agent UI',
      attributes: JSON.stringify(attrs)
    });

    pushEvent('TASK_COMPLETED', {
      taskSid: updated.sid,
      workerSid: req.claims?.workerSid || null,
      disposition: disposition || null,
      reason: reason || null
    });

    try {
      await axios.post('https://analytics.example.com/track', {
        disposition,
        duration: task.age,
        intent: attrs.intent,
      });
    } catch (analyticsError) {
      console.warn('Analytics post failed', analyticsError);
    }

    return res.json({
      sid: updated.sid,
      assignmentStatus: updated.assignmentStatus,
      reason: updated.reason || null
    });
  } catch (e) {
    console.error('[COMPLETE_TASK] error:', e);
    return res.status(500).json({ error: 'cannot complete task' });
  }
}

/* ---------------------------
 * Available Workers (for transfer lists)
 * --------------------------- */
export async function availableWorkers(_req, res) {
  try {
    const acts = await listActivities();
    const availableSids = acts.filter(a => a.available).map(a => a.sid);
    const workers = await listWorkers();
    const out = [];
    for (const w of workers) {
      if (!availableSids.includes(w.activitySid)) continue;
      let contact = null;
      try {
        const attrs = JSON.parse(w.attributes || '{}');
        contact = attrs.contact_uri || null;
      } catch {}
      out.push({ workerSid: w.sid, friendlyName: w.friendlyName, contactUri: contact });
    }
    res.json(out);
  } catch (e) {
    console.error('[AVAILABLE_WORKERS] error', e);
    res.status(500).json({ error: 'cannot list available workers' });
  }
}

/* ---------------------------
 * Presence (with tiny cache to avoid thundering-herd)
 * --------------------------- */
let _presenceCache = { at: 0, data: [] };

export async function presence(_req, res) {
  try {
    // 2s soft TTL cache
    if (Date.now() - _presenceCache.at > 2000) {
      const workers = await listWorkersWithRetry();
      _presenceCache = { at: Date.now(), data: workers };
    }

    const workers = _presenceCache.data;
    const out = workers.map(w => {
      let contact = null;
      try { contact = JSON.parse(w.attributes || '{}').contact_uri || null; } catch {}
      return {
        workerSid: w.sid,
        friendlyName: w.friendlyName,
        activitySid: w.activitySid,
        activityName: w.activityName,
        available: !!w.available,
        contactUri: contact
      };
    });
    res.json(out);
  } catch (e) {
    console.error('[PRESENCE] upstream error:', e?.code || e?.message || e);
    res.status(502).json({ error: 'twilio_unreachable', detail: 'Network or DNS issue reaching Twilio TaskRouter' });
  }
}

/* ---------------------------
 * Recent in-memory events (debug)
 * --------------------------- */
export function recent(_req, res) {
  res.json(recentEvents());
}

==== /src\controllers\taskrouter.js ====

==== src\controllers\tokens.js ====
﻿import crypto from 'crypto';
import { signAgentToken } from 'shared/auth';
import { serverEnv as env } from 'shared/env';
import { fetchWorker, createVoiceToken, createWorkerToken } from '../services/tokens.js';

const refreshTokens = new Map();

const accessCookieOpts = {
  httpOnly: true,
  secure: env.cookieSecure,
  sameSite: 'strict',
  domain: env.cookieDomain,
  maxAge: 8 * 60 * 60 * 1000,
};

const refreshCookieOpts = {
  httpOnly: true,
  secure: env.cookieSecure,
  sameSite: 'strict',
  domain: env.cookieDomain,
  maxAge: 30 * 24 * 60 * 60 * 1000,
};

function getCookie(req, name) {
  const raw = req.headers?.cookie;
  if (!raw) return undefined;
  return raw
    .split(';')
    .map(c => c.trim())
    .find(c => c.startsWith(`${name}=`))
    ?.split('=')[1];
}

function toContactUri(raw) {
  const val = String(raw || '').trim();
  if (!val) return '';
  if (val.startsWith('client:')) return val;
  if (val.startsWith('agent:')) return `client:${val}`;
  return `client:agent:${val}`;
}

export async function login(req, res) {
  const { agentId, workerSid, identity } = req.body;
  if (!agentId || !workerSid || identity == null) {
    return res.status(400).json({ error: 'missing fields' });
  }
  try {
    const worker = await fetchWorker(workerSid);
    const attrs = JSON.parse(worker.attributes || '{}');
    const normalized = toContactUri(identity);
    if (!attrs.contact_uri || attrs.contact_uri !== normalized) {
      return res.status(400).json({
        error: 'identity mismatch with worker.contact_uri',
        expected: normalized,
        got: attrs.contact_uri || null,
        hint: 'Verifica que el Worker tenga attributes.contact_uri igual al expected.'
      });
    }
    const access = signAgentToken(agentId, workerSid, normalized);
    const refresh = crypto.randomUUID();
    refreshTokens.set(refresh, { agentId, workerSid, identity: normalized });
    res.cookie(env.accessTokenName, access, accessCookieOpts);
    res.cookie(env.refreshTokenName, refresh, refreshCookieOpts);
    return res.json({
      agent: { id: agentId, workerSid, identity: normalized }
    });
  } catch (e) {
    console.error('[AUTH/LOGIN] Error fetching worker or TR config:', e?.message || e);
    return res.status(400).json({ error: 'invalid workerSid or TR config' });
  }
}

export function me(req, res) {
  const token = getCookie(req, env.refreshTokenName);
  if (!token || !refreshTokens.has(token)) {
    return res.status(401).json({ error: 'invalid refresh token' });
  }
  const { agentId, workerSid, identity } = refreshTokens.get(token);
  const access = signAgentToken(agentId, workerSid, identity);
  res.cookie(env.accessTokenName, access, accessCookieOpts);
  return res.json({ agent: { id: agentId, workerSid, identity } });
}

export function refresh(req, res) {
  const token = getCookie(req, env.refreshTokenName);
  if (!token || !refreshTokens.has(token)) {
    return res.status(401).json({ error: 'invalid refresh token' });
  }
  const { agentId, workerSid, identity } = refreshTokens.get(token);
  const access = signAgentToken(agentId, workerSid, identity);
  res.cookie(env.accessTokenName, access, accessCookieOpts);
  return res.json({ ok: true });
}

export function logout(req, res) {
  const token = getCookie(req, env.refreshTokenName);
  if (token) refreshTokens.delete(token);
  res.clearCookie(env.accessTokenName, { domain: env.cookieDomain });
  res.clearCookie(env.refreshTokenName, { domain: env.cookieDomain });
  res.status(204).end();
}

export function voiceToken(req, res) {
  try {
    const { identity } = req.claims;
    if (!identity) {
      return res.status(400).json({ error: 'missing identity in claims' });
    }
    const missing = [];
    if (!env.accountSid) missing.push('TWILIO_ACCOUNT_SID');
    if (!env.apiKey) missing.push('TWILIO_API_KEY_SID');
    if (!env.apiSecret) missing.push('TWILIO_API_KEY_SECRET');
    if (missing.length) {
      console.error('[VOICE_TOKEN] Missing ENV:', missing);
      return res.status(500).json({ error: 'voice token build failed: missing env', missing });
    }
    const token = createVoiceToken(identity);
    return res.json({ token });
  } catch (e) {
    console.error('[VOICE_TOKEN] Error building token:', e);
    return res.status(500).json({
      error: 'voice token build failed',
      details: e?.message || String(e)
    });
  }
}

export function workerToken(req, res) {
  const { workerSid } = req.claims;
  const missing = [];
  if (!env.accountSid) missing.push('TWILIO_ACCOUNT_SID');
  if (!env.authToken) missing.push('TWILIO_AUTH_TOKEN');
  if (!env.workspaceSid) missing.push('TR_WORKSPACE_SID');
  if (!workerSid) {
    return res.status(400).json({ error: 'missing workerSid in claims' });
  }
  if (missing.length) {
    console.error('[TR_WORKER_TOKEN] Missing ENV:', missing);
    return res.status(500).json({
      error: 'worker token build failed: missing env',
      missing
    });
  }
  try {
    const token = createWorkerToken(workerSid);
    return res.json({ token });
  } catch (e) {
    console.error('[TR_WORKER_TOKEN] Error building token:', e?.message || e);
    return res.status(500).json({ error: 'worker token build failed' });
  }
}


==== /src\controllers\tokens.js ====

==== src\controllers\transfer.js ====
import { env, waitUntilInProgress, updateCall, createCall } from '../services/transfer.js';

function esc(s) {
  return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;');
}

function conferenceTwiml(name, { endOnExit = false, beep = false } = {}) {
  return `
<Response>
  <Dial callerId="${esc(env.callerId)}">
    <Conference beep="${beep ? 'true' : 'false'}"
                endConferenceOnExit="${endOnExit ? 'true' : 'false'}">${esc(name)}</Conference>
  </Dial>
</Response>`.trim();
}

function normalizeTargetIdentity(targetIdentity) {
  const raw = String(targetIdentity || '').trim();
  if (!raw) return '';
  if (raw.startsWith('client:')) return raw;
  if (raw.startsWith('agent:')) return `client:${raw}`;
  return `client:agent:${raw}`;
}

export async function cold(req, res) {
  try {
    const { customerCallSid, targetIdentity, agentCallSid } = req.body || {};
    if (!customerCallSid || !targetIdentity) {
      return res.status(400).json({ error: 'missing customerCallSid or targetIdentity' });
    }
    const toClient = normalizeTargetIdentity(targetIdentity);
    if (!toClient) return res.status(400).json({ error: 'invalid targetIdentity' });
    try {
      await waitUntilInProgress(customerCallSid);
    } catch (e) {
      return res.status(409).json({
        error: 'call not in-progress',
        details: e.message,
        twilioStatus: e.twilioStatus || undefined
      });
    }
    const twiml = `
<Response>
  <Dial callerId="${esc(env.callerId)}">
    <Client>${esc(toClient.replace('client:', ''))}</Client>
  </Dial>
</Response>`.trim();
    await updateCall(customerCallSid, { twiml });
    if (agentCallSid) {
      try { await updateCall(agentCallSid, { status: 'completed' }); } catch {}
    }
    return res.json({ ok: true, mode: 'cold' });
  } catch (e) {
    console.error('[TRANSFER/COLD] error', e);
    return res.status(500).json({ error: 'cold transfer failed' });
  }
}

export async function warm(req, res) {
  try {
    const { taskSid, customerCallSid, agentCallSid, targetIdentity } = req.body || {};
    if (!customerCallSid || !agentCallSid || !targetIdentity) {
      return res.status(400).json({ error: 'missing required fields' });
    }
    const toClient = normalizeTargetIdentity(targetIdentity);
    if (!toClient) return res.status(400).json({ error: 'invalid targetIdentity' });
    try {
      await waitUntilInProgress(customerCallSid);
      await waitUntilInProgress(agentCallSid);
    } catch (e) {
      return res.status(409).json({
        error: 'call not in-progress',
        details: e.message,
        twilioStatus: e.twilioStatus || undefined
      });
    }
    const confName = taskSid ? `task-${taskSid}` : `xfer-${customerCallSid}`;
    const twimlCustomer = conferenceTwiml(confName, { endOnExit: true, beep: false });
    await updateCall(customerCallSid, { twiml: twimlCustomer });
    const twimlAgent = conferenceTwiml(confName, { endOnExit: false, beep: false });
    await updateCall(agentCallSid, { twiml: twimlAgent });
    const twimlTarget = conferenceTwiml(confName, { endOnExit: false, beep: true });
    await createCall({ to: toClient, from: env.callerId, twiml: twimlTarget });
    return res.json({ ok: true, mode: 'warm', conference: confName });
  } catch (e) {
    console.error('[TRANSFER/WARM] error', e);
    return res.status(500).json({ error: 'warm transfer failed' });
  }
}

export async function complete(req, res) {
  try {
    const { agentCallSid } = req.body || {};
    if (!agentCallSid) return res.status(400).json({ error: 'missing agentCallSid' });
    await updateCall(agentCallSid, { status: 'completed' });
    return res.json({ ok: true });
  } catch (e) {
    console.error('[TRANSFER/COMPLETE] error', e);
    return res.status(500).json({ error: 'complete transfer failed' });
  }
}

==== /src\controllers\transfer.js ====

==== src\controllers\video.js ====
// contact-center/server/src/controllers/video.js
import { rest } from '../twilio.js';
import { buildVideoToken } from '../twilio.js';
import { fetchConversation, updateConversationAttributes, listParticipants } from '../conversations/service.js';

const ENABLED = String(process.env.ENABLE_VIDEO || 'false').toLowerCase() === 'true';

// ✅ Usa 'group' por defecto y valida tipos permitidos
const ROOM_TYPE_ENV = (process.env.VIDEO_ROOM_TYPE || 'group').trim();
const ALLOWED_TYPES = new Set(['group', 'group-small', 'peer-to-peer', 'go']);
const ROOM_TYPE = ALLOWED_TYPES.has(ROOM_TYPE_ENV) ? ROOM_TYPE_ENV : 'group';

const MAX_AGENTS = parseInt(process.env.VIDEO_MAX_AGENTS_PER_ROOM || '1', 10) || 1;
// Opcional: const REGION = process.env.VIDEO_REGION;

/* =========================
 * Helpers
 * ========================= */
function roomNameFor({ conversationSid, taskSid, name }) {
  if (name) return name;
  if (conversationSid) return `conv_${conversationSid}`;
  if (taskSid) return `task_${taskSid}`;
  return `room_${Date.now()}`;
}

/** Extrae ConversationSid desde un roomName conv_CHxxxxxxxx... */
function parseConversationSidFromRoomName(roomName) {
  const m = String(roomName || '').match(/^conv_(CH[a-zA-Z0-9]{32})$/);
  return m ? m[1] : null;
}

function cleanIdentity(identity) {
  const raw = String(identity || '').trim();
  return raw.startsWith('client:') ? raw.slice('client:'.length) : raw;
}

/** Verifica que identity sea participante de la Conversation */
async function assertParticipant({ conversationSid, identity }) {
  if (!conversationSid || !identity) {
    const err = new Error('conversationSid and identity required');
    err.status = 400;
    throw err;
  }
  // Asegura que la conversación exista
  await fetchConversation(conversationSid);
  // Lista participantes y valida
  const parts = await listParticipants(conversationSid);
  const who = cleanIdentity(identity);
  const ok = parts.some((p) => p.identity === who);
  if (!ok) {
    const err = new Error('identity is not a participant of this conversation');
    err.status = 403;
    throw err;
  }
}

async function ensureRoom({ uniqueName }) {
  try {
    const existing = await rest.video.v1.rooms(uniqueName).fetch();
    const st = String(existing.status || '').toLowerCase();
    if (['in-progress', 'connected', 'open'].includes(st)) return existing;
    // Si está 'completed', crea nuevo con sufijo
    uniqueName = `${uniqueName}_${Date.now()}`;
  } catch {
    // 404 => crear
  }

  // Crear con el tipo elegido y reintentar con 'group' si Twilio rechaza el tipo (legacy/invalid)
  try {
    return await rest.video.v1.rooms.create({
      uniqueName,
      type: ROOM_TYPE,
      // recordParticipantsOnConnect: false,
      // region: REGION || undefined,
    });
  } catch (e) {
    const msg = String(e?.message || '').toLowerCase();
    const isTypeErr =
      e?.status === 400 ||
      msg.includes('legacy room type') ||
      msg.includes('unsupported') ||
      msg.includes('invalid "type"') ||
      msg.includes('room type');

    if (isTypeErr && ROOM_TYPE !== 'group') {
      // Fallback robusto a 'group'
      return await rest.video.v1.rooms.create({
        uniqueName,
        type: 'group',
      });
    }
    throw e;
  }
}

// Evita 2 agentes en la misma sala
async function agentSlotAvailable(uniqueName, identity) {
  try {
    const list = await rest.video.v1.rooms(uniqueName)
      .participants
      .list({ status: 'connected', limit: 50 });
    const agents = list.filter((p) => String(p.identity || '').startsWith('agent:'));
    // Si el mismo agente reintenta, permitimos
    if (agents.some((a) => a.identity === cleanIdentity(identity))) return true;
    return agents.length < MAX_AGENTS;
  } catch {
    // Si no se puede listar, preferimos dejar pasar para no bloquear operativa
    return true;
  }
}

/* =========================
 * Controller
 * ========================= */
export const videoController = {
  enabled: (_req, res) => res.json({ enabled: ENABLED }),

  /**
   * Crea/obtiene Room y (si hay Conversation) marca atributos.
   * Seguridad:
   *  - Si viene identity (agente via JWT o guest via body), validamos pertenencia.
   *  - Si NO viene identity (p.ej., webchat antiguo), permitimos crear la sala pero
   *    la emisión del token (siguiente paso) sí validará pertenencia.
   */
  ensureRoom: async (req, res) => {
    try {
      if (!ENABLED) return res.status(404).json({ error: 'video disabled' });

      const { conversationSid, taskSid, name, identity: bodyIdentity } = req.body || {};
      const claimsIdentity = req.claims?.identity; // presente si el caller es agente autenticado
      const callerIdentity = claimsIdentity || bodyIdentity || null;

      // Si tenemos identidad y conversationSid, validamos pertenencia:
      if (callerIdentity && conversationSid) {
        await assertParticipant({ conversationSid, identity: callerIdentity });
      }

      const uniqueName = roomNameFor({ conversationSid, taskSid, name });
      const room = await ensureRoom({ uniqueName });

      if (conversationSid) {
        try {
          await updateConversationAttributes(conversationSid, {
            video: { roomName: room.uniqueName, roomSid: room.sid, startedAt: new Date().toISOString() }
          });
        } catch (e) {
          // no bloqueante
          console.warn('[video/ensure-room] updateConversationAttributes skipped:', e?.message || e);
        }
      }

      res.json({ roomName: room.uniqueName, roomSid: room.sid, type: room.type });
    } catch (e) {
      const code = e.status || 500;
      console.error('[video/ensure-room]', e?.message || e);
      res.status(code).json({ error: e.message || 'cannot ensure room' });
    }
  },

  /**
   * Token para AGENTE (cookie/JWT requerida a nivel de router).
   * Adicionalmente:
   *  - si el roomName está ligado a una conversación (conv_CH...), validamos que el agente sea participante del chat.
   *  - limitamos el número de agentes simultáneos por sala con MAX_AGENTS.
   */
  tokenAgent: async (req, res) => {
    try {
      if (!ENABLED) return res.status(404).json({ error: 'video disabled' });
      const identity = req.claims?.identity;
      const { roomName } = req.query || {};
      if (!identity || !roomName) return res.status(400).json({ error: 'missing identity or roomName' });

      const convSid = parseConversationSidFromRoomName(roomName);
      if (convSid) {
        await assertParticipant({ conversationSid: convSid, identity });
      }

      const allowed = await agentSlotAvailable(roomName, identity);
      if (!allowed) return res.status(409).json({ error: 'room already has an agent' });

      const token = buildVideoToken(identity, roomName);
      res.json({ token, identity });
    } catch (e) {
      const code = e.status || 500;
      console.error('[video/tokenAgent]', e?.message || e);
      res.status(code).json({ error: e.message || 'cannot issue token' });
    }
  },

  /**
   * Token para invitado (webchat público).
   * Seguridad:
   *  - exigimos que roomName tenga formato conv_{ConversationSid}.
   *  - validamos que identity pertenezca a esa Conversation antes de emitir token.
   */
  tokenGuest: async (req, res) => {
    try {
      if (!ENABLED) return res.status(404).json({ error: 'video disabled' });

      const identity = String(req.query.identity || '').trim(); // ej: "guest:uuid"
      const roomName = String(req.query.roomName || '').trim();
      if (!identity || !roomName) return res.status(400).json({ error: 'identity and roomName required' });

      const conversationSid = parseConversationSidFromRoomName(roomName);
      if (!conversationSid) return res.status(400).json({ error: 'invalid roomName (must be conv_{ConversationSid})' });

      await assertParticipant({ conversationSid, identity });

      const token = buildVideoToken(identity, roomName);
      res.json({ token, identity });
    } catch (e) {
      const code = e.status || 500;
      console.error('[video/tokenGuest]', e?.message || e);
      res.status(code).json({ error: e.message || 'cannot issue guest token' });
    }
  },
};

==== /src\controllers\video.js ====

==== src\controllers\voice.js ====
// contact-center/server/src/controllers/voice.js
import { buildOutboundTwiml } from '../services/voice.js';

/**
 * TwiML para salientes desde la TwiML App.
 * Acepta To (destino) y callerId/ANI opcional para sobrescribir el callerId por defecto.
 * (Twilio sólo acepta callerId si es un número Twilio tuyo o un Verified Caller ID).
 */
export function outbound(req, res) {
  const to = (req.body.To || '').trim();
  const callerId = (req.body.callerId || req.body.ANI || '').trim(); // llega desde Device.connect params
  const twiml = buildOutboundTwiml(to, callerId);
  return res.type('text/xml').status(200).send(twiml);
}

==== /src\controllers\voice.js ====

==== src\controllers\voiceControl.js ====
import { rest } from '../twilio.js';
import {  waitForConferenceByName,
  waitForConferenceBySid,
  waitForParticipantByCallSid,
  waitUntilParticipantConnected,
  getConferenceFromTask,
  ensureConferenceReadyByName,
  updateHold,
  latestRecordingForCall,
  createRecording,
  updateRecording,
  createParticipant,
  env
} from '../services/voiceControl.js';
import { pushEvent } from '../services/taskrouter.js';

const holdMap = new Map();

export async function holdStart(req, res) {
  try {
    const { taskSid, customerCallSid, agentCallSid, who = 'customer' } = req.body || {};
    if (!customerCallSid || !agentCallSid) {
      return res.status(400).json({ error: 'missing callSids', need: ['customerCallSid','agentCallSid'] });
    }
    let confSid, targetCallSid;
    if (taskSid) {
      const info = await getConferenceFromTask(taskSid);
      if (info?.confSid) {
        confSid = info.confSid;
        targetCallSid = (who === 'agent')
          ? (info.workerCallSid || agentCallSid)
          : (info.customerCallSid || customerCallSid);
        await waitForConferenceBySid(confSid);
      } else {
        const conf = await waitForConferenceByName(taskSid);
        confSid = conf.sid;
        targetCallSid = (who === 'agent') ? agentCallSid : customerCallSid;
      }
    } else {
      const conf = await ensureConferenceReadyByName({
        confName: `xfer-${customerCallSid}`,
        customerCallSid,
        agentCallSid
      });
      confSid = conf.sid;
      targetCallSid = (who === 'agent') ? agentCallSid : customerCallSid;
    }
    await waitForParticipantByCallSid(confSid, targetCallSid);
    await waitUntilParticipantConnected(confSid, targetCallSid);
    await updateHold(confSid, targetCallSid, true, env.holdMusicUrl);
    holdMap.set(targetCallSid, Date.now());
    pushEvent('HOLD_START', { confSid, target: who });
    res.json({ ok: true, confSid, who });
  } catch (e) {
    console.error('[HOLD/START] error', e);
    res.status(500).json({ error: 'cannot hold', details: e?.message });
  }
}

export async function holdStop(req, res) {
  try {
    const { taskSid, customerCallSid, agentCallSid, who = 'customer' } = req.body || {};
    if (!customerCallSid || !agentCallSid) {
      return res.status(400).json({ error: 'missing callSids', need: ['customerCallSid','agentCallSid'] });
    }
    let confSid, targetCallSid;
    if (taskSid) {
      const info = await getConferenceFromTask(taskSid);
      if (info?.confSid) {
        confSid = info.confSid;
        targetCallSid = (who === 'agent')
          ? (info.workerCallSid || agentCallSid)
          : (info.customerCallSid || customerCallSid);
        await waitForConferenceBySid(confSid);
      } else {
        const conf = await waitForConferenceByName(taskSid);
        confSid = conf.sid;
        targetCallSid = (who === 'agent') ? agentCallSid : customerCallSid;
      }
    } else {
      const conf = await waitForConferenceByName(`xfer-${customerCallSid}`);
      confSid = conf.sid;
      targetCallSid = (who === 'agent') ? agentCallSid : customerCallSid;
    }
    await waitForParticipantByCallSid(confSid, targetCallSid);
    await waitUntilParticipantConnected(confSid, targetCallSid);
    await updateHold(confSid, targetCallSid, false, undefined);
    const holdStart = holdMap.get(targetCallSid);
    if (holdStart) {
      const duration = Math.floor((Date.now() - holdStart) / 1000);
      holdMap.delete(targetCallSid);
      console.log(`Hold duration for ${targetCallSid}: ${duration}s`);
    }
    pushEvent('HOLD_STOP', { confSid, target: who });
    res.json({ ok: true, confSid, who });
  } catch (e) {
    console.error('[HOLD/STOP] error', e);
    res.status(500).json({ error: 'cannot unhold', details: e?.message });
  }
}

export async function hangupCall(req, res) {
  try {
    const { callSid } = req.body || {};
    if (!callSid) return res.status(400).json({ error: 'missing callSid' });
    await rest.calls(callSid).update({ status: 'completed' });
    res.json({ ok: true });
  } catch (e) {
    console.error('[HANGUP] error', e);
    res.status(500).json({ error: 'cannot hangup call', details: e?.message });
  }
}

export async function recordingStatus(req, res) {
  try {
    const { callSid } = req.query || {};
    if (!callSid) return res.status(400).json({ error: 'missing callSid' });
    const rec = await latestRecordingForCall(callSid);
    const status = rec ? rec.status : 'inactive';
    res.json({ status });
  } catch (e) {
    console.error('[REC/STATUS] error', e);
    res.status(500).json({ error: 'cannot get recording status', details: e?.message });
  }
}

export async function recordingStart(req, res) {
  try {
    const { callSid } = req.body || {};
    if (!callSid) return res.status(400).json({ error: 'missing callSid' });
    const rec = await createRecording(callSid);
    pushEvent('REC_START', { callSid, recordingSid: rec.sid });
    res.json({ ok: true, recordingSid: rec.sid });
  } catch (e) {
    console.error('[REC/START] error', e);
    res.status(500).json({ error: 'cannot start recording', details: e?.message });
  }
}

export async function recordingPause(req, res) {
  try {
    const { callSid } = req.body || {};
    if (!callSid) return res.status(400).json({ error: 'missing callSid' });
    const rec = await latestRecordingForCall(callSid);
    if (!rec) return res.status(404).json({ error: 'no recording found' });
    await updateRecording(callSid, rec.sid, { status: 'paused', pauseBehavior: 'silence' });
    pushEvent('REC_PAUSE', { callSid, recordingSid: rec.sid });
    res.json({ ok: true, recordingSid: rec.sid });
  } catch (e) {
    console.error('[REC/PAUSE] error', e);
    res.status(500).json({ error: 'cannot pause recording', details: e?.message });
  }
}

export async function recordingResume(req, res) {
  try {
    const { callSid } = req.body || {};
    if (!callSid) return res.status(400).json({ error: 'missing callSid' });
    const rec = await latestRecordingForCall(callSid);
    if (!rec) return res.status(404).json({ error: 'no recording found' });
    await updateRecording(callSid, rec.sid, { status: 'in-progress' });
    pushEvent('REC_RESUME', { callSid, recordingSid: rec.sid });
    res.json({ ok: true, recordingSid: rec.sid });
  } catch (e) {
    console.error('[REC/RESUME] error', e);
    res.status(500).json({ error: 'cannot resume recording', details: e?.message });
  }
}

export async function recordingStop(req, res) {
  try {
    const { callSid } = req.body || {};
    if (!callSid) return res.status(400).json({ error: 'missing callSid' });
    const rec = await latestRecordingForCall(callSid);
    if (!rec) return res.status(404).json({ error: 'no recording found' });
    await updateRecording(callSid, rec.sid, { status: 'stopped' });
    pushEvent('REC_STOP', { callSid, recordingSid: rec.sid });
    res.json({ ok: true, recordingSid: rec.sid });
  } catch (e) {
    console.error('[REC/STOP] error', e);
    res.status(500).json({ error: 'cannot stop recording', details: e?.message });
  }
}

export async function superviseWhisper(req, res) {
  try {
    const { conferenceName, supervisorIdentity, coachCallSid } = req.body || {};
    if (!conferenceName || !supervisorIdentity || !coachCallSid) {
      return res.status(400).json({ error: 'missing fields' });
    }
    const conf = await waitForConferenceByName(conferenceName);
    const to = supervisorIdentity.startsWith('client:') ? supervisorIdentity : `client:${supervisorIdentity}`;
    const participant = await createParticipant(conf.sid, {
      to,
      from: env.callerId,
      earlyMedia: true,
      coaching: true,
      callSidToCoach: coachCallSid
    });
    pushEvent('SUPERVISE_WHISPER', { conferenceSid: conf.sid, supervisorIdentity, coachCallSid });
    res.json({ ok: true, participantSid: participant.callSid });
  } catch (e) {
    console.error('[SUPERVISE/WHISPER] error', e);
    res.status(500).json({ error: 'cannot create whisper participant', details: e?.message });
  }
}

export async function superviseBarge(req, res) {
  try {
    const { conferenceName, supervisorIdentity } = req.body || {};
    if (!conferenceName || !supervisorIdentity) {
      return res.status(400).json({ error: 'missing fields' });
    }
    const conf = await waitForConferenceByName(conferenceName);
    const to = supervisorIdentity.startsWith('client:') ? supervisorIdentity : `client:${supervisorIdentity}`;
    const participant = await createParticipant(conf.sid, {
      to,
      from: env.callerId,
      earlyMedia: true,
      coaching: false
    });
    pushEvent('SUPERVISE_BARGE', { conferenceSid: conf.sid, supervisorIdentity });
    res.json({ ok: true, participantSid: participant.callSid });
  } catch (e) {
    console.error('[SUPERVISE/BARGE] error', e);
    res.status(500).json({ error: 'cannot create barge participant', details: e?.message });
  }
}

==== /src\controllers\voiceControl.js ====

==== src\conversations\client.js ====
import twilio from 'twilio';


const {
TWILIO_ACCOUNT_SID,
TWILIO_AUTH_TOKEN,
TWILIO_REGION, // optional e.g. 'au1'
TWILIO_EDGE, // optional e.g. 'sydney'
} = process.env;


if (!TWILIO_ACCOUNT_SID || !TWILIO_AUTH_TOKEN) {
throw new Error('Missing TWILIO_ACCOUNT_SID/TWILIO_AUTH_TOKEN');
}


/**
* Twilio client with sensible defaults
*/
export const twilioClient = twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, {
autoRetry: true,
maxRetries: 3,
keepAlive: true,
region: TWILIO_REGION || undefined,
edge: TWILIO_EDGE || undefined,
});
==== /src\conversations\client.js ====

==== src\conversations\service.js ====
import { twilioClient as client } from './client.js';

const {
  TWILIO_MESSAGING_SERVICE_SID,
  TWILIO_SMS_NUMBER,
  TWILIO_WHATSAPP_NUMBER,
  TWILIO_MESSENGER_PAGE_ID,
  TWILIO_CONVERSATIONS_SERVICE_SID,
} = process.env;

if (!TWILIO_CONVERSATIONS_SERVICE_SID) {
  console.warn('[Conversations] TWILIO_CONVERSATIONS_SERVICE_SID is not configured');
}

const service = TWILIO_CONVERSATIONS_SERVICE_SID
  ? client.conversations.v1.services(TWILIO_CONVERSATIONS_SERVICE_SID)
  : null;

function requireService() {
  if (!service) {
    throw new Error('TWILIO_CONVERSATIONS_SERVICE_SID is required to use Conversations APIs');
  }
}

export async function getOrCreateConversation({ uniqueName, friendlyName, attributes = {} }) {
  requireService();
  if (!uniqueName) throw new Error('uniqueName required');
  try {
    return await service.conversations(uniqueName).fetch();
  } catch (err) {
    if (err.status !== 404) throw err;
    const convo = await service.conversations.create({
      uniqueName,
      friendlyName: friendlyName || uniqueName,
      attributes: JSON.stringify({ ...attributes, taskSid: null }),
      messagingServiceSid: TWILIO_MESSAGING_SERVICE_SID || undefined,
    });
    return service.conversations(convo.sid).update({
      'timers.inactive': 'PT15M',
      'timers.closed': 'P1D',
    });
  }
}

export async function addChatParticipant(conversationSid, { identity, attributes } = {}) {
  requireService();
  if (!identity) throw new Error('identity required');
  try {
    return await service
      .conversations(conversationSid)
      .participants.create({
        identity,
        attributes: attributes ? JSON.stringify(attributes) : undefined,
      });
  } catch (err) {
    if (err.status === 409 || err.code === 50433) {
      try {
        const existing = await service
          .conversations(conversationSid)
          .participants
          .list({ limit: 50 });
        const found = existing.find(p => p.identity === identity);
        if (found) return found;
        throw new Error('Participant already exists but could not be located via list()');
      } catch (fetchErr) {
        throw new Error(
          `Participant already exists but could not be fetched: ${fetchErr.message}`
        );
      }
    }
    throw new Error(
      `Failed to add participant ${identity} to conversation ${conversationSid}: ${err.message}`
    );
  }
}

export function addSmsParticipant(conversationSid, { to, from }) {
  requireService();
  const proxy = from || TWILIO_SMS_NUMBER;
  if (!to || !proxy) throw new Error('to and from (or TWILIO_SMS_NUMBER) are required');
  return service.conversations(conversationSid).participants.create({
    'messagingBinding.address': to,
    'messagingBinding.proxyAddress': proxy
  });
}

export function addWhatsappParticipant(conversationSid, { to, from }) {
  requireService();
  const proxy = from || TWILIO_WHATSAPP_NUMBER;
  if (!to || !proxy) throw new Error('to and from (or TWILIO_WHATSAPP_NUMBER) are required');
  return service.conversations(conversationSid).participants.create({
    'messagingBinding.address': `whatsapp:${to}`,
    'messagingBinding.proxyAddress': `whatsapp:${proxy}`,
  });
}

export function addMessengerParticipant(conversationSid, { userId, pageId }) {
  requireService();
  const proxy = pageId || TWILIO_MESSENGER_PAGE_ID;
  if (!userId || !proxy) throw new Error('userId and pageId (or TWILIO_MESSENGER_PAGE_ID) are required');
  return service.conversations(conversationSid).participants.create({
    'messagingBinding.address': `messenger:${userId}`,
    'messagingBinding.proxyAddress': `messenger:${proxy}`,
  });
}

export function sendMessage(conversationSid, { author = 'system', body, mediaSid, attributes }) {
  requireService();
  const payload = { author };
  if (body) payload.body = body;
  if (mediaSid) payload.mediaSid = mediaSid;
  if (attributes) payload.attributes = JSON.stringify(attributes);
  const webhookHeader = { xTwilioWebhookEnabled: 'true' };
  return service.conversations(conversationSid).messages.create(payload, webhookHeader);
}

export function attachWebhook(conversationSid, { target = 'webhook', url, method = 'post', filters = ['onMessageAdded'], flowSid }) {
  requireService();
  const cfg = {};
  if (target === 'webhook') {
    if (!url) throw new Error('url is required when target=webhook');
    cfg['configuration.url'] = url;
    cfg['configuration.method'] = method;
    cfg['configuration.filters'] = filters;
  } else if (target === 'studio') {
    if (!flowSid) throw new Error('flowSid is required when target=studio');
    cfg['configuration.flowSid'] = flowSid;
  }
  return service.conversations(conversationSid).webhooks.create({ target, ...cfg });
}

export const fetchConversation = (sid) => {
  requireService();
  return service.conversations(sid).fetch();
};

export async function updateConversationAttributes(conversationSid, newAttributes = {}) {
  requireService();
  const convo = await fetchConversation(conversationSid);
  const current =
    typeof convo.attributes === 'string'
      ? (convo.attributes ? JSON.parse(convo.attributes) : {})
      : (convo.attributes || {});
  const merged = { ...current, ...newAttributes };
  return service.conversations(conversationSid).update({
    attributes: JSON.stringify(merged),
  });
}

export function listMessageReceipts(conversationSid, messageSid) {
  requireService();
  if (!conversationSid || !messageSid) {
    throw new Error('conversationSid and messageSid are required');
  }
  return service
    .conversations(conversationSid)
    .messages(messageSid)
    .deliveryReceipts.list();
}

export function updateConversationTimers(conversationSid, { inactive, closed } = {}) {
  requireService();
  const payload = {};
  if (inactive) payload['timers.inactive'] = inactive;
  if (closed) payload['timers.closed'] = closed;
  return service.conversations(conversationSid).update(payload);
}

/* ===== NUEVO: helpers para cierre “duro” ===== */

export function listParticipants(conversationSid) {
  requireService();
  return service.conversations(conversationSid).participants.list({ limit: 200 });
}

export async function removeAllParticipants(conversationSid) {
  requireService();
  const parts = await listParticipants(conversationSid);
  let removed = 0;
  for (const p of parts) {
    try {
      await service.conversations(conversationSid).participants(p.sid).remove();
      removed++;
    } catch (e) {
      console.warn('[Conversations] remove participant failed', p.sid, e?.message || e);
    }
  }
  return { removed, total: parts.length };
}

export async function closeConversation(conversationSid, { removeParticipants = true } = {}) {
  requireService();
  await service.conversations(conversationSid).update({
    'timers.inactive': 'PT0S',
    'timers.closed': 'PT0S',
  });
  if (removeParticipants) {
    await removeAllParticipants(conversationSid);
  }
  try {
    const convo = await fetchConversation(conversationSid);
    return { ok: true, state: convo.state || convo.status || 'unknown' };
  } catch {
    return { ok: true };
  }
}

export function configureServiceWebhooks({
  preWebhookUrl,
  postWebhookUrl,
  method = 'POST',
  filters = ['onMessageAdd', 'onConversationAdd'],
} = {}) {
  if (!service) {
    console.warn('[Conversations] Skipping service webhook configuration: TWILIO_CONVERSATIONS_SERVICE_SID is not set');
    return Promise.resolve();
  }

  const payload = {};
  if (preWebhookUrl) payload.preWebhookUrl = preWebhookUrl;
  if (postWebhookUrl) payload.postWebhookUrl = postWebhookUrl;
  if (filters) payload.filters = filters;
  if (method) payload.method = method;

  if (Object.keys(payload).length === 0) return Promise.resolve();

  return service.configuration.webhooks().update(payload);
}

==== /src\conversations\service.js ====

==== src\conversations\tokens.js ====
import twilio from 'twilio';

const { AccessToken } = twilio.jwt;
const { ChatGrant, SyncGrant } = AccessToken;

const {
  TWILIO_ACCOUNT_SID,
  TWILIO_API_KEY_SID,
  TWILIO_API_KEY_SECRET,
  TWILIO_CONVERSATIONS_SERVICE_SID, // IS... (Conversations)
  TWILIO_SYNC_SERVICE_SID,          // IS... (Sync)  <-- opcional, distinto del de arriba
} = process.env;

export function createConversationsToken(identity, ttlSeconds = 3600) {
  if (!identity) throw new Error('identity is required');

  const token = new AccessToken(
    TWILIO_ACCOUNT_SID,
    TWILIO_API_KEY_SID,
    TWILIO_API_KEY_SECRET,
    { identity, ttl: ttlSeconds }
  );

  // Requerido para Conversations
  token.addGrant(new ChatGrant({ serviceSid: TWILIO_CONVERSATIONS_SERVICE_SID }));

  // Opcional: SOLO si realmente usas Sync y tienes el IS correcto de Sync
  if (TWILIO_SYNC_SERVICE_SID) {
    token.addGrant(new SyncGrant({ serviceSid: TWILIO_SYNC_SERVICE_SID }));
  }
  // Nota: NO hagas `new SyncGrant()` sin serviceSid.

  return token.toJwt();
}

==== /src\conversations\tokens.js ====

==== src\index.js ====
﻿// contact-center/server/src/index.js
import express from 'express';
import cors from 'cors';
import http from 'http';
import { Server } from 'socket.io';
import rateLimit from 'express-rate-limit';
import { serverEnv as env } from 'shared/env';
import { tokens } from './routes/tokens.js';
import { health } from './routes/health.js';
import { taskrouter } from './routes/taskrouter.js';
import { voice } from './routes/voice.js';
import { validateEnv } from './validateEnv.js';
import { transfer } from './routes/transfer.js';
import { voiceControl } from './routes/voiceControl.js';
import { ivr } from './routes/ivr.js';
import { crmProxy } from './routes/crm.js';
import chatTokenRoute from './routes/chat-token.route.js';
import conversationsRoute from './routes/conversations.route.js';
import conversationsWebhooksRoute from './routes/conversations-webhooks.route.js';
import conversationsPreWebhooksRoute from './routes/conversations-prewebhooks.route.js';
import { configureServiceWebhooks } from './conversations/service.js';
import { video as videoRoutes } from './routes/video.js';

// 🚀 Nuevo: rutas de demo (llamadas de prueba Phone Lab)
import demoRoutes from './routes/demo-routes.js';

const app = express();
validateEnv();
// Si estás detrás de 1 proxy (ngrok, render, etc.), usa 1 o 'loopback'.
// En local puedes usar false.
app.set('trust proxy', 'loopback'); // o 1
// --- CORS config (HTTP & Socket.IO) ---
const corsOrigins = (env.corsOrigin || '')
  .split(',')
  .map(s => s.trim())
  .filter(Boolean);

const origin =
  env.corsOrigin === '*'
    ? true
    : corsOrigins.length
      ? corsOrigins
      : false; // false = bloquea si no hay match

const corsOptions = {
  origin,
  methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  exposedHeaders: ['Content-Type', 'Authorization'],
  credentials: true, // si no usas cookies, puedes dejarlo en false; con Authorization no hay problema
  maxAge: 86400,     // cache preflight 24h
};

app.use(express.urlencoded({ extended: false }));
app.use(express.json());
app.use(cors(corsOptions));
app.options('*', cors(corsOptions)); // preflight global

// --- Rutas API ---
app.use('/api', health);
app.use('/api', tokens);
app.use('/api', taskrouter);
app.use('/api', voice);
app.use('/api', transfer);
app.use('/api', voiceControl);
app.use('/api/ivr/finance', rateLimit({ windowMs: 15 * 60 * 1000, max: 5 }));
app.use('/api', ivr);
app.use('/api', crmProxy);
app.use('/api/chat', chatTokenRoute);
app.use('/api', videoRoutes);
app.use('/api/conversations', conversationsRoute);
app.use('/webhooks/conversations/pre', conversationsPreWebhooksRoute);
app.use('/webhooks/conversations', conversationsWebhooksRoute);

// --- Rutas DEMO (Phone Lab / softphone embebido) ---
// El frontend llama a: POST ${API_BASE}/demo/call/start
// Por eso montamos el router exactamente en /demo (sin /api).
app.use('/demo', rateLimit({ windowMs: 15 * 60 * 1000, max: 15 }));
app.use('/demo', demoRoutes);

if (env.publicBaseUrl) {
  configureServiceWebhooks({
    preWebhookUrl: `${env.publicBaseUrl}/webhooks/conversations/pre`,
    postWebhookUrl: `${env.publicBaseUrl}/webhooks/conversations`,
    // Un solo "filters" sirve para pre y post; incluye eventos pre y post.
    filters: [
      'onConversationAdd', 'onMessageAdd',                    // PRE
      'onMessageAdded', 'onMessageUpdated', 'onMessageRemoved',// POST
      'onParticipantAdded', 'onParticipantRemoved',
      'onDeliveryUpdated', 'onConversationStateUpdated'
    ],
    method: 'POST'
  }).catch(e => console.error('Failed to configure Conversations webhooks', e));
}

// --- HTTP + Socket.IO con CORS ---
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin,
    methods: ['GET', 'POST'],
    credentials: true,
  },
});

// comparte io con los routers para poder emitir eventos (p. ej. presence_update)
app.set('io', io);

server.listen(env.port, () => console.log(`server on :${env.port}`));

==== /src\index.js ====

==== src\lib\crmClient.js ====
﻿// contact-center/server/src/lib/crmClient.js
import jwt from 'jsonwebtoken';
import { serverEnv as env } from 'shared/env';

async function doFetch(path, { method = 'GET', body, qs } = {}) {
  const url = new URL(env.crmOrchBaseUrl.replace(/\/+$/, '') + path);
  if (qs) Object.entries(qs).forEach(([k, v]) => url.searchParams.set(k, v));

  const token = jwt.sign(
    { aud: env.crmOrchAudience, iss: env.crmOrchIssuer },
    env.crmOrchKey,
    { expiresIn: '60s' }
  );

  const res = await fetch(url, {
    method,
    headers: {
      'content-type': 'application/json',
      authorization: `Bearer ${token}`
    },
    body: body ? JSON.stringify(body) : undefined
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => '');
    throw new Error(`CRM ${res.status}: ${txt || res.statusText}`);
  }
  return res.json();
}

export const crm = {
  // NEW
  vehicleById: id => doFetch(`/v1/vehicles/${encodeURIComponent(id)}`),

  customerByAni: ani => doFetch(`/v1/customers/by-ani/${encodeURIComponent(ani)}`),
  customerById: id => doFetch(`/v1/customers/${encodeURIComponent(id)}`),
  vehicleByVin: vin => doFetch(`/v1/vehicles/by-vin/${encodeURIComponent(vin)}`),
  vehicleByPlate: plate => doFetch(`/v1/vehicles/by-plate/${encodeURIComponent(plate)}`),
  appointments: vehicleId => doFetch(`/v1/appointments/${encodeURIComponent(vehicleId)}`),
  createAppointment: payload => doFetch(`/v1/appointments`, { method: 'POST', body: payload }),
  recallsByVin: vin => doFetch(`/v1/recalls/${encodeURIComponent(vin)}`),
  finance: (customerId, otpVerified = false) =>
    doFetch(`/v1/finance/${encodeURIComponent(customerId)}`, { qs: { otpVerified: String(otpVerified) } }),
  payLink: customerId => doFetch(`/v1/paylink`, { method: 'POST', body: { customerId } }),
  logInteraction: payload => doFetch(`/v1/interactions`, { method: 'POST', body: payload })
};


==== /src\lib\crmClient.js ====

==== src\middleware\verifyTwilio.js ====
import twilio from 'twilio';
import { serverEnv as env } from 'shared/env';

export function verifyTwilioSignature(req, res, next) {
  if (env.skipTwilioValidation) return next();

  try {
    const signature = req.get('X-Twilio-Signature');
    if (!signature) return res.status(403).send('Missing Twilio signature');

    const base = env.publicBaseUrl || `${req.protocol}://${req.get('host')}`;
    const url = base + req.originalUrl;
    const params = req.body || {};

    const valid = twilio.webhook.validateRequest(
      env.authToken,
      signature,
      url,
      params
    );
    if (!valid) return res.status(403).send('Invalid Twilio signature');

    return next();
  } catch {
    return res.status(403).send('Twilio validation error');
  }
}


==== /src\middleware\verifyTwilio.js ====

==== src\routes\chat-token.route.js ====
import express from 'express';
import crypto from 'crypto';
import { requireAuth } from 'shared/auth';
import { createConversationsToken } from '../conversations/tokens.js';

const router = express.Router();

/** Normaliza identidad para Conversations (sin prefijo "client:"). */
function normalizeIdentity(raw) {
  if (!raw) return '';
  return raw.startsWith('client:') ? raw.slice('client:'.length) : raw;
}

/**
 * ===============================
 *   TOKENS PARA AGENTE (AUTH)
 * ===============================
 * Estos endpoints requieren sesión (cookies/JWT) y devuelven un token con
 * identidad del agente (p.ej. "agent:42"). Úsalos desde el Agent Desktop.
 */

/** Token para agente (1h). Requiere haber hecho login /auth/login. */
router.get('/token', requireAuth, (req, res) => {
  try {
    const raw = req.claims?.identity || '';
    const identity = normalizeIdentity(raw);
    if (!identity) return res.status(400).json({ error: 'invalid identity' });
    const token = createConversationsToken(identity, 3600);
    return res.json({ token, identity });
  } catch (e) {
    return res.status(500).json({ error: e.message });
  }
});

/** Refresh del token del agente. Acepta ?identity= opcional; por defecto usa la del JWT. */
router.get('/refresh', requireAuth, (req, res) => {
  try {
    const raw = String(req.query.identity || req.claims?.identity || '').trim();
    const identity = normalizeIdentity(raw);
    if (!identity) return res.status(400).json({ error: 'identity is required' });
    const token = createConversationsToken(identity, 3600);
    return res.json({ token });
  } catch (e) {
    return res.status(500).json({ error: e.message });
  }
});

/**
 * =================================
 *   TOKENS PARA INVITADO (PÚBLICO)
 * =================================
 * Úsalos ÚNICAMENTE desde tu “webchat” público/embebido (no autenticado).
 * El cliente DEBE persistir la identidad devuelta para hacer refresh luego.
 */

/** Token guest (1h). */
router.get('/token/guest', (_req, res) => {
  try {
    const identity = `guest:${crypto.randomUUID()}`;
    const token = createConversationsToken(identity, 3600);
    return res.json({ token, identity });
  } catch (e) {
    return res.status(500).json({ error: e.message });
  }
});

/** Refresh guest. Requiere ?identity=guest:... */
router.get('/refresh/guest', (req, res) => {
  const identity = String(req.query.identity || '').trim();
  if (!identity) return res.status(400).json({ error: 'identity is required' });
  if (identity.startsWith('client:')) {
    return res.status(400).json({ error: 'pass identity without "client:" prefix' });
  }
  try {
    const token = createConversationsToken(identity, 3600);
    return res.json({ token });
  } catch (e) {
    return res.status(500).json({ error: e.message });
  }
});

export default router;

==== /src\routes\chat-token.route.js ====

==== src\routes\conversations-prewebhooks.route.js ====
import express from 'express';
import { fetchConversation } from '../conversations/service.js';
import { verifyTwilioSignature } from '../middleware/verifyTwilio.js';

const router = express.Router();

// Simple content moderation placeholder. In a real implementation
// you might call an external service or a more sophisticated model.
const MAX_MESSAGE_LENGTH = 1600;
const bannedWords = ['banned', 'profanity'];

// Allowed email domains for new conversations
const allowedDomains = (process.env.ALLOWED_EMAIL_DOMAINS || '')
  .split(',')
  .map(s => s.trim().toLowerCase())
  .filter(Boolean);

// Toggle: conversación única (true) o nueva por sesión (false)
const SINGLE_CHAT_SESSION = String(process.env.SINGLE_CHAT_SESSION ?? 'true').toLowerCase() !== 'false';

function failsModeration(body = '') {
  const lower = body.toLowerCase();
  return bannedWords.some(w => lower.includes(w));
}

router.post('/', verifyTwilioSignature, async (req, res) => {
  const eventType = req.body.EventType || req.body.EventType?.toString();
  console.log('[Conversations PreWebhook]', eventType, req.body?.MessageSid || req.body?.ConversationSid || '');

  try {
    if (eventType === 'onConversationAdd') {
      let attrs = {};
      try {
        attrs = req.body.Attributes ? JSON.parse(req.body.Attributes) : {};
      } catch (err) {
        // Be permissive: log and allow the conversation creation to proceed.
        console.warn('[Conversations PreWebhook] Invalid attributes JSON; allowing conversation add');
        return res.status(200).send('ok');
      }

      const email = attrs.email ? String(attrs.email).toLowerCase() : '';

      // If you enforce domain policies, only do it when an email was actually provided.
      if (email) {
        const domain = email.split('@')[1];
        if (allowedDomains.length && !allowedDomains.includes(domain)) {
          return res.status(403).send('email domain not allowed');
        }

        // Unicidad por email SOLO si SINGLE_CHAT_SESSION=true
        if (SINGLE_CHAT_SESSION) {
          try {
            await fetchConversation(email);
            return res.status(409).send('conversation already exists');
          } catch (err) {
            if (err.status && err.status !== 404) {
              console.error('[Conversations PreWebhook] uniqueness check failed', err);
              return res.status(500).send('error');
            }
            // 404 => not found => ok (allow creation)
          }
        }
      }

      // If no email is present, allow the conversation to be created so
      // post-webhooks (onParticipantAdded) can create the Task immediately.
    }

    if (eventType === 'onMessageAdd') {
      const body = req.body.Body || '';

      if (body.length > MAX_MESSAGE_LENGTH) {
        return res.status(413).send('Message too long');
      }

      if (failsModeration(body)) {
        return res.status(422).send('Message failed moderation');
      }
    }

    res.status(200).send('ok');
  } catch (e) {
    console.error('[Conversations PreWebhook] error:', e);
    res.status(500).send('error');
  }
});

export default router;

==== /src\routes\conversations-prewebhooks.route.js ====

==== src\routes\conversations-webhooks.route.js ====
import express from 'express';
import {
  createTask,
  completeTask,
  fetchTask,
  pushEvent,
  updateTask,
  listWorkers,
  listWorkerReservations,
  acceptReservation
} from '../services/taskrouter.js';
import { fetchConversation, updateConversationAttributes } from '../conversations/service.js';
import { logInteraction } from '../services/crm.js';
import { verifyTwilioSignature } from '../middleware/verifyTwilio.js';

const router = express.Router();

function toContactUri(identity) {
  const raw = String(identity || '').trim();
  if (!raw) return null;
  if (raw.startsWith('client:')) return raw;
  if (raw.startsWith('agent:')) return `client:${raw}`;
  return `client:agent:${raw}`;
}

/** Devuelve true si no hay task o si el task está cerrado/no existe. */
async function isTaskClosedOrMissing(taskSid) {
  if (!taskSid) return true;
  try {
    const t = await fetchTask(taskSid);
    const st = String(t.assignmentStatus || '').toLowerCase();
    return ['completed', 'canceled', 'timeout', 'deleted'].includes(st);
  } catch {
    return true; // si no existe o no se puede leer, trátalo como cerrado/missing
  }
}

// Twilio will POST events like onMessageAdded here if you attach a webhook per-conversation.
router.post('/', verifyTwilioSignature, async (req, res) => {
  const eventType = req.body.EventType || req.body.EventType?.toString();
  console.log('[Conversations Webhook]', eventType, req.body?.MessageSid || '');
  const io = req.app.get('io');
  try {
    if (eventType === 'onMessageAdded') {
      const author = String(req.body.Author || '').toLowerCase();
      let participantAttrs = {};
      try {
        participantAttrs = req.body.ParticipantAttributes
          ? JSON.parse(req.body.ParticipantAttributes)
          : {};
      } catch {
        participantAttrs = {};
      }
      if (author !== 'system' && participantAttrs.role !== 'agent') {
        const conversationSid = req.body.ConversationSid;
        const convo = await fetchConversation(conversationSid);
        const convoAttrs = convo.attributes ? JSON.parse(convo.attributes) : {};
        if (await isTaskClosedOrMissing(convoAttrs.taskSid)) {
          const task = await createTask({
            attributes: {
              channel: 'chat',
              conversationSid,
              direction: 'inbound',
              ...convoAttrs
            },
            taskChannel: 'chat'
          });
          await updateConversationAttributes(conversationSid, {
            taskSid: task.sid,
            agentJoinedAt: null
          });
          pushEvent('TASK_CREATED', { taskSid: task.sid, conversationSid });
          io?.emit('task_created', { taskSid: task.sid, conversationSid });
        }
      }
    } else if (eventType === 'onMessageUpdated') {
      const conversationSid = req.body.ConversationSid;
      const messageSid = req.body.MessageSid;
      const body = req.body.Body;
      const convo = await fetchConversation(conversationSid);
      const attrs = convo.attributes ? JSON.parse(convo.attributes) : {};
      const transcript = attrs.transcript || {};
      const existing = transcript[messageSid] || {};
      const previousBody = existing.body || req.body.PreviousBody || null;
      transcript[messageSid] = { ...existing, body, updatedAt: new Date().toISOString() };
      await updateConversationAttributes(conversationSid, { transcript });
      pushEvent('MESSAGE_UPDATED', { conversationSid, messageSid, body });
      io?.emit('message_updated', { conversationSid, messageSid, body });
      if (previousBody && previousBody !== body) {
        try {
          await logInteraction({ conversationSid, messageSid, type: 'message_updated', previousBody });
        } catch (err) {
          console.warn('logInteraction failed (non-blocking)', err);
        }
      }
    } else if (eventType === 'onMessageRemoved') {
      const conversationSid = req.body.ConversationSid;
      const messageSid = req.body.MessageSid;
      const convo = await fetchConversation(conversationSid);
      const attrs = convo.attributes ? JSON.parse(convo.attributes) : {};
      const transcript = attrs.transcript || {};
      const removed = transcript[messageSid];
      delete transcript[messageSid];
      await updateConversationAttributes(conversationSid, { transcript });
      pushEvent('MESSAGE_REMOVED', { conversationSid, messageSid });
      io?.emit('message_removed', { conversationSid, messageSid });
      const previousBody = req.body.PreviousBody || removed?.body;
      if (previousBody) {
        try {
          await logInteraction({ conversationSid, messageSid, type: 'message_removed', previousBody });
        } catch (err) {
          console.warn('logInteraction failed (non-blocking)', err);
        }
      }
    } else if (eventType === 'onParticipantAdded') {
      const conversationSid = req.body.ConversationSid;
      const participantSid = req.body.ParticipantSid;
      const identity = req.body.Identity;
      let participantAttrs = {};
      try {
        participantAttrs = req.body.ParticipantAttributes
          ? JSON.parse(req.body.ParticipantAttributes)
          : {};
      } catch {
        participantAttrs = {};
      }

      const convo = await fetchConversation(conversationSid);
      const attrs = convo.attributes ? JSON.parse(convo.attributes) : {};
      const participants = attrs.participants || {};
      participants[participantSid] = { identity, role: participantAttrs.role };

      const updates = { participants };
      const now = new Date().toISOString();

      // Crear Task inmediato si se une cliente y no hay Task ACTIVO
      if (participantAttrs.role !== 'agent' && (await isTaskClosedOrMissing(attrs.taskSid))) {
        const task = await createTask({
          attributes: {
            channel: 'chat',
            conversationSid,
            direction: 'inbound',
            ...attrs
          },
          taskChannel: 'chat'
        });
        updates.taskSid = task.sid;
        pushEvent('TASK_CREATED', { taskSid: task.sid, conversationSid });
        io?.emit('task_created', { taskSid: task.sid, conversationSid });
      }

      if (participantAttrs.role === 'agent' && !attrs.agentJoinedAt) {
        updates.agentJoinedAt = now;
        if (attrs.taskSid) {
          try {
            const task = await fetchTask(attrs.taskSid);
            const tAttrs = task.attributes ? JSON.parse(task.attributes) : {};

            const selectedContactUri = toContactUri(identity);
            const mergedTaskAttrs = { ...tAttrs, selected_contact_uri: selectedContactUri };
            await updateTask(attrs.taskSid, {
              attributes: JSON.stringify(mergedTaskAttrs),
              priority: Math.max(100, Number(task.priority || 0))
            });
            await updateConversationAttributes(conversationSid, { selected_contact_uri: selectedContactUri });

            pushEvent('TASK_UPDATED', { taskSid: attrs.taskSid, conversationSid });
            io?.emit('task_updated', { taskSid: attrs.taskSid, conversationSid });

            try {
              const workers = await listWorkers();
              const myWorker = workers.find(w => {
                try {
                  const wAttrs = JSON.parse(w.attributes || '{}');
                  return wAttrs.contact_uri === selectedContactUri;
                } catch { return false; }
              });

              if (myWorker) {
                let accepted = false;
                for (let i = 0; i < 8 && !accepted; i++) {
                  const resvs = await listWorkerReservations(myWorker.sid);
                  const mine = resvs.find(r => r.taskSid === attrs.taskSid && String(r.reservationStatus).toLowerCase() === 'pending');
                  if (mine) {
                    await acceptReservation(myWorker.sid, mine.sid);
                    pushEvent('RESERVATION_ACCEPTED', { taskSid: attrs.taskSid, workerSid: myWorker.sid, reservationSid: mine.sid });
                    io?.emit('reservation_accepted', { taskSid: attrs.taskSid, workerSid: myWorker.sid, reservationSid: mine.sid });
                    accepted = true;
                    break;
                  }
                  await new Promise(r => setTimeout(r, 400));
                }
              }
            } catch (autoErr) {
              console.warn('[AUTO_ACCEPT] failed', autoErr?.message || autoErr);
            }
          } catch (err) {
            console.error('task update error', err);
          }
        }
      }

      await updateConversationAttributes(conversationSid, updates);
      const payload = { conversationSid, participantSid, identity, role: participantAttrs.role };
      pushEvent('PARTICIPANT_ADDED', payload);
      io?.emit('participant_added', payload);

    } else if (eventType === 'onParticipantRemoved') {
      const conversationSid = req.body.ConversationSid;
      const participantSid = req.body.ParticipantSid;
      let participantAttrs = {};
      try {
        participantAttrs = req.body.ParticipantAttributes
          ? JSON.parse(req.body.ParticipantAttributes)
          : {};
      } catch {
        participantAttrs = {};
      }
      const convo = await fetchConversation(conversationSid);
      const attrs = convo.attributes ? JSON.parse(convo.attributes) : {};
      const participants = attrs.participants || {};
      const removed = participants[participantSid];
      delete participants[participantSid];
      await updateConversationAttributes(conversationSid, { participants });
      const payload = { conversationSid, participantSid, identity: removed?.identity, role: removed?.role };
      pushEvent('PARTICIPANT_REMOVED', payload);
      io?.emit('participant_removed', payload);
      const remainingAgents = Object.values(participants).some((p) => p.role === 'agent');
      if (!remainingAgents && attrs.taskSid) {
        try {
          await updateTask(attrs.taskSid, { assignmentStatus: 'wrapping', reason: 'agent left' });
        } catch (err) {
          console.error('task escalation error', err);
        }
        pushEvent('CHAT_ORPHANED', { conversationSid, taskSid: attrs.taskSid });
        io?.emit('chat_orphaned', { conversationSid, taskSid: attrs.taskSid });
      }
    } else if (eventType === 'onConversationStateUpdated') {
      const status = String(req.body.Status || '').toLowerCase();
      if (status === 'closed') {
        const conversationSid = req.body.ConversationSid;
        const convo = await fetchConversation(conversationSid);
        const attrs = convo.attributes ? JSON.parse(convo.attributes) : {};
        const taskSid = attrs.taskSid;
        if (taskSid) {
          // Move task to WRAPPING instead of auto-completing
          await updateTask(taskSid, {
            assignmentStatus: 'wrapping',
            reason: 'Conversation closed',
            attributes: JSON.stringify({ ...attrs, wrapup_reason: 'Conversation closed' })
          });
          pushEvent('TASK_WRAPPING', { taskSid, conversationSid });
          io?.emit('task_wrapping', { taskSid, conversationSid });
        }
      }
    } else if (eventType === 'onConversationRemoved') {
      const conversationSid = req.body.ConversationSid;
      let attrs = {};
      try {
        attrs = req.body.Attributes ? JSON.parse(req.body.Attributes) : {};
      } catch {
        attrs = {};
      }
      const taskSid = attrs.taskSid;
      if (taskSid) {
        await completeTask(taskSid, 'Conversation removed');
        pushEvent('TASK_COMPLETED', { taskSid, conversationSid });
        io?.emit('task_completed', { taskSid, conversationSid });
      }
      try {
        await logInteraction({ conversationSid, taskSid, type: 'conversation_removed' });
      } catch (err) {
        console.warn('CRM cleanup failed', err);
      }
      pushEvent('CONVERSATION_REMOVED', { conversationSid, taskSid: taskSid || null });
      io?.emit('conversation_removed', { conversationSid, taskSid: taskSid || null });
    } else if (eventType === 'onDeliveryUpdated') {
      const conversationSid = req.body.ConversationSid;
      const messageSid = req.body.MessageSid;
      const deliveryStatus = req.body.DeliveryStatus;
      if (conversationSid && messageSid && deliveryStatus) {
        const convo = await fetchConversation(conversationSid);
        const attrs = convo.attributes ? JSON.parse(convo.attributes) : {};
        const receipts = attrs.deliveryReceipts || {};
        receipts[messageSid] = deliveryStatus;
        await updateConversationAttributes(conversationSid, { deliveryReceipts: receipts });
        pushEvent('MESSAGE_DELIVERY_UPDATED', { conversationSid, messageSid, deliveryStatus });
        io?.emit('message_delivery_updated', { conversationSid, messageSid, deliveryStatus });
      }
    }
    res.status(200).send('ok');
  } catch (e) {
    console.error('[Conversations Webhook] error:', e);
    res.status(500).send('error');
  }
});

export default router;

==== /src\routes\conversations-webhooks.route.js ====

==== src\routes\conversations.route.js ====
// contact-center/server/src/routes/conversations.route.js
import express from 'express';
import { serverEnv as env } from 'shared/env';
import {
  getOrCreateConversation,
  addChatParticipant,
  addSmsParticipant,
  addWhatsappParticipant,
  addMessengerParticipant,
  sendMessage,
  attachWebhook,
  updateConversationTimers,
  listMessageReceipts,
  closeConversation,
  fetchConversation,
  listParticipants,
  updateConversationAttributes,
} from '../conversations/service.js';
import { createTask, pushEvent, fetchTask } from '../services/taskrouter.js';

const router = express.Router();

/* ----------------------------- utils ----------------------------- */
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

function safeJsonParse(maybeJson, fallback = {}) {
  try {
    if (maybeJson == null) return fallback;
    if (typeof maybeJson === 'object') return maybeJson;
    return JSON.parse(maybeJson);
  } catch {
    return fallback;
  }
}

function filterTaskAttrs(attrs) {
  const omit = new Set([
    'transcript',
    'deliveryReceipts',
    'participants',
    'timers',
    'taskSid',
  ]);
  const out = {};
  for (const [k, v] of Object.entries(attrs || {})) {
    if (omit.has(k)) continue;
    out[k] = v;
  }
  if (!out.channel) out.channel = 'chat';
  return out;
}

/** Toggle: conversación única por identificador o nueva por sesión */
const SINGLE_CHAT_SESSION = String(process.env.SINGLE_CHAT_SESSION ?? 'true').toLowerCase() !== 'false';

/** Evita doble creación cuando hay carreras */
const creatingTaskFor = new Set();
async function ensureTaskForConversation(conversationSid, baseAttrs = {}, io) {
  if (!conversationSid) return null;

  if (creatingTaskFor.has(conversationSid)) {
    // Espera breve por si otra rama lo completa
    for (let i = 0; i < 6; i++) await sleep(80);
  }
  creatingTaskFor.add(conversationSid);

  try {
    const convo = await fetchConversation(conversationSid);
    const attrs = safeJsonParse(convo.attributes, {});
    // Si hay taskSid, úsalo solo si sigue activo
    if (attrs.taskSid) {
      try {
        const t = await fetchTask(attrs.taskSid);
        const st = String(t.assignmentStatus || '').toLowerCase();
        if (!['completed', 'canceled', 'timeout', 'deleted'].includes(st)) {
          return attrs.taskSid;
        }
      } catch {
        // taskSid inválido → continuar a crear nuevo
      }
    }

    const task = await createTask({
      attributes: {
        ...filterTaskAttrs(attrs),
        ...filterTaskAttrs(baseAttrs),
        conversationSid,
        direction: attrs.direction || baseAttrs.direction || 'inbound',
      },
      taskChannel: 'chat',
    });

    await updateConversationAttributes(conversationSid, { taskSid: task.sid, agentJoinedAt: null });
    pushEvent('TASK_CREATED', { taskSid: task.sid, conversationSid });
    io?.emit?.('task_created', { taskSid: task.sid, conversationSid });
    return task.sid;
  } finally {
    creatingTaskFor.delete(conversationSid);
  }
}

/* ----------------------------- routes ----------------------------- */

// Create or get a conversation by uniqueName
router.post('/', async (req, res) => {
  let { uniqueName, friendlyName, attributes } = req.body || {};
  try {
    // Fuente de identidad/identifier (email o externalId)
    const idHint =
      attributes?.email ||
      attributes?.identifier ||
      attributes?.externalId ||
      uniqueName ||
      'chat';

    if (SINGLE_CHAT_SESSION) {
      // conservar una única Conversation por identificador
      uniqueName = uniqueName || idHint;
    } else {
      // forzar una Conversation nueva por sesión
      uniqueName = `${idHint}::${Date.now()}::${Math.random().toString(36).slice(2, 8)}`;
    }

    const convo = await getOrCreateConversation({ uniqueName, friendlyName, attributes });

    // (Opcional) Adjunta webhook por-conversación para mayor resiliencia
    try {
      if (env.publicBaseUrl) {
        await attachWebhook(convo.sid, {
          target: 'webhook',
          url: `${env.publicBaseUrl}/webhooks/conversations`,
          method: 'POST',
          filters: ['onParticipantAdded', 'onMessageAdded', 'onConversationStateUpdated'],
        });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.warn('[attachWebhook] skipped/failed:', e?.message || e);
    }

    res.json(convo);
  } catch (e) {
    res.status(e.status || 500).json({ error: e.message });
  }
});

// Add a participant; body.type: chat|sms|whatsapp|messenger
router.post('/:sid/participants', async (req, res) => {
  const { sid } = req.params;
  const { type } = req.body;
  const io = req.app.get('io');

  try {
    let result;

    switch (type) {
      case 'chat': {
        const { identity, attributes } = req.body;
        result = await addChatParticipant(sid, { identity, attributes });

        // Crear Task INMEDIATO si el participante NO es agente
        const role = String(attributes?.role || '').toLowerCase();
        if (role !== 'agent') {
          await ensureTaskForConversation(sid, { direction: 'inbound' }, io);
        }
        break;
      }

      case 'sms': {
        const { to, from } = req.body;
        result = await addSmsParticipant(sid, { to, from });
        break;
      }

      case 'whatsapp': {
        const { to, from } = req.body;
        result = await addWhatsappParticipant(sid, { to, from });
        break;
      }

      case 'messenger': {
        const { userId, pageId } = req.body;
        result = await addMessengerParticipant(sid, { userId, pageId });
        break;
      }

      default:
        return res.status(400).json({ error: 'Unsupported type' });
    }

    res.json(result);
  } catch (e) {
    res.status(e.status || 500).json({ error: e.message });
  }
});

// Send a message
router.post('/:sid/messages', async (req, res) => {
  const { sid } = req.params;
  try {
    const msg = await sendMessage(sid, req.body);
    res.json(msg);
  } catch (e) {
    res.status(e.status || 500).json({ error: e.message });
  }
});

// Retrieve delivery receipts for a message
router.get('/:sid/messages/:messageSid/receipts', async (req, res) => {
  const { sid, messageSid } = req.params;
  try {
    const receipts = await listMessageReceipts(sid, messageSid);
    res.json(receipts);
  } catch (e) {
    res.status(e.status || 500).json({ error: e.message });
  }
});

// Quick state probe for smart UI
router.get('/:sid/state', async (req, res) => {
  const { sid } = req.params;
  try {
    const convo = await fetchConversation(sid);
    const stateRaw = convo?.state || convo?.status || 'unknown';
    const state = String(stateRaw).toLowerCase();
    let participantsCount;
    try {
      const parts = await listParticipants(sid);
      participantsCount = parts?.length ?? undefined;
    } catch {
      participantsCount = undefined;
    }
    res.json({ sid, state, closed: state === 'closed', participantsCount });
  } catch (e) {
    res.status(e.status || 500).json({ error: e.message });
  }
});

// Legacy/fallback timers update
router.post('/:sid/timers', async (req, res) => {
  const { sid } = req.params;
  try {
    const convo = await updateConversationTimers(sid, req.body);
    res.json(convo);
  } catch (e) {
    res.status(e.status || 500).json({ error: e.message });
  }
});

// Close conversation hard (timers to PT0S + remove participants)
router.post('/:sid/close', async (req, res) => {
  const { sid } = req.params;
  const { removeParticipants = true } = req.body || {};
  try {
    const out = await closeConversation(sid, { removeParticipants });
    res.json(out);
  } catch (e) {
    res.status(e.status || 500).json({ error: e.message });
  }
});

// Attach a Conversation-scoped webhook (manual)
router.post('/:sid/webhooks', async (req, res) => {
  const { sid } = req.params;
  try {
    const wh = await attachWebhook(sid, req.body);
    res.json(wh);
  } catch (e) {
    res.status(e.status || 500).json({ error: e.message });
  }
});

export default router;

==== /src\routes\conversations.route.js ====

==== src\routes\crm.js ====
﻿import { Router } from 'express';
import { requireAuth } from 'shared/auth';
import {
  getVehicleById,
  getCustomerById,
  getVehicleByPlate,
  getVehicleByVin,
  getAppointments,
  postAppointment,
  getFinance,
  postPayLink,
  postInteraction
} from '../controllers/crm.js';

export const crmProxy = Router();
crmProxy.use('/crm', requireAuth);
crmProxy.get('/crm/vehicles/by-id/:id', getVehicleById);
crmProxy.get('/crm/customers/:id', getCustomerById);
crmProxy.get('/crm/vehicles/by-plate/:plate', getVehicleByPlate);
crmProxy.get('/crm/vehicles/:vin', getVehicleByVin);
crmProxy.get('/crm/appointments/:vehicleId', getAppointments);
crmProxy.post('/crm/appointments', postAppointment);
crmProxy.get('/crm/finance/:customerId', getFinance);
crmProxy.post('/crm/paylink', postPayLink);
crmProxy.post('/crm/interactions', postInteraction);


==== /src\routes\crm.js ====

==== src\routes\demo-routes.js ====
// server/demo-routes.js
import express from 'express';
import twilio from 'twilio';
import { serverEnv as env } from 'shared/env';
import { buildVoiceToken } from '../twilio.js';

const router = express.Router();

const {
  TWILIO_ACCOUNT_SID,
  TWILIO_AUTH_TOKEN
} = process.env;

const client = twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);

// Único destino permitido por ahora (IVR del demo)
const ALLOWED_TO = new Set(['+12058275832']);

/**
 * ✅ Token de Voice (público para el demo)
 * Requiere en el .env:
 *  - TWILIO_ACCOUNT_SID
 *  - TWILIO_API_KEY_SID
 *  - TWILIO_API_KEY_SECRET
 *  - TWIML_APP_SID          (muy importante para salientes)
 *
 * Nota: buildVoiceToken añade VoiceGrant con outgoingApplicationSid=TWIML_APP_SID.
 */
router.get('/token/voice', (req, res) => {
  try {
    const identity = String(req.query.identity || 'softphone:alex').trim();

    const missing = [];
    if (!env.accountSid) missing.push('TWILIO_ACCOUNT_SID');
    if (!env.apiKey)     missing.push('TWILIO_API_KEY_SID');
    if (!env.apiSecret)  missing.push('TWILIO_API_KEY_SECRET');
    if (!env.twimlAppSid) missing.push('TWIML_APP_SID'); // necesario para device.connect() → /api/voice/outbound

    if (missing.length) {
      return res.status(500).json({
        error: 'missing env',
        missing
      });
    }

    const token = buildVoiceToken(identity);
    return res.json({ token, identity });
  } catch (e) {
    console.error('[demo/token/voice] error', e);
    return res.status(500).json({ error: e?.message || 'token failed' });
  }
});

/**
 * ☎️ Fallback REST: inicia llamada desde el servidor (sin WebRTC en el browser).
 * Queda para demo; el UI usa WebRTC primero y cae aquí si falla la inicialización.
 */
router.post('/call/start', async (req, res) => {
  try {
    const { to, from, dtmf } = req.body || {};

    if (!to || !from) return res.status(400).json({ error: 'Missing to/from' });
    if (!ALLOWED_TO.has(to)) return res.status(400).json({ error: 'TO not allowed for demo' });

    // "1-2-1" → "1w2w1" (w = 0.5s)
    const digits = String(dtmf || '')
      .trim()
      .replace(/[^\d\-w]/g, '')
      .replace(/-+/g, 'w');

    const vr = new twilio.twiml.VoiceResponse();
    if (digits) {
      vr.pause({ length: 1 });
      vr.play({ digits });
    }
    // Mantener “viva” la llamada hasta 10 min para navegar el IVR si hiciera falta:
    vr.pause({ length: 600 });

    const call = await client.calls.create({
      to,
      from,
      twiml: vr.toString(),
      // statusCallback: `${env.publicBaseUrl}/demo/call/status`,
      // statusCallbackEvent: ['initiated','ringing','answered','completed'],
    });

    return res.json({ ok: true, sid: call.sid });
  } catch (err) {
    console.error('[demo/call/start] error', err);
    return res.status(500).json({ error: err.message || 'call failed' });
  }
});

export default router;

==== /src\routes\demo-routes.js ====

==== src\routes\health.js ====
import { Router } from 'express';
import { getHealth } from '../controllers/health.js';

export const health = Router().get('/health', getHealth);

==== /src\routes\health.js ====

==== src\routes\ivr.js ====
import { Router } from 'express';
import {
  lookup,
  serviceStatus,
  scheduleService,
  checkRecalls,
  financeBalance,
  financePaylink
} from '../controllers/ivr.js';

export const ivr = Router();
ivr.post('/ivr/lookup', lookup);
ivr.post('/ivr/service/status', serviceStatus);
ivr.post('/ivr/service/schedule', scheduleService);
ivr.post('/ivr/recalls/check', checkRecalls);
ivr.post('/ivr/finance/balance', financeBalance);
ivr.post('/ivr/finance/paylink', financePaylink);

==== /src\routes\ivr.js ====

==== src\routes\taskrouter.js ====
﻿﻿import { Router } from 'express';
import { verifyTwilioSignature } from '../middleware/verifyTwilio.js';
import { requireAuth } from 'shared/auth';
import {
  assignment,
  events,
  activities,
  myTasks,
  completeTask,
  availableWorkers,
  presence,
  recent,
  wrapTask,            // NUEVO
} from '../controllers/taskrouter.js';

export const taskrouter = Router();
taskrouter.post('/taskrouter/assignment', verifyTwilioSignature, assignment);
taskrouter.post('/taskrouter/events', verifyTwilioSignature, events);
taskrouter.get('/taskrouter/activities', activities);
taskrouter.get('/taskrouter/my-tasks', requireAuth, myTasks);

// NUEVO: Forzar WRAPPING (chat)
taskrouter.post('/taskrouter/tasks/:taskSid/wrap', requireAuth, wrapTask);

// Completar (acepta autoWrap)
taskrouter.post('/taskrouter/tasks/:taskSid/complete', requireAuth, completeTask);

taskrouter.get('/taskrouter/available-workers', requireAuth, availableWorkers);
taskrouter.get('/taskrouter/presence', requireAuth, presence);
// Public demo (sin JWT) para el KPI del sitio
taskrouter.get('/taskrouter/presence/public', presence);
taskrouter.get('/events/recent', requireAuth, recent);

==== /src\routes\taskrouter.js ====

==== src\routes\tokens.js ====
﻿import { Router } from 'express';
import { requireAuth } from 'shared/auth';
import { login, me, refresh, logout, voiceToken, workerToken } from '../controllers/tokens.js';

export const tokens = Router();
tokens.post('/auth/login', login);
tokens.post('/auth/refresh', refresh);
tokens.post('/auth/logout', logout);
tokens.get('/auth/me', requireAuth, me);
tokens.get('/token/voice', requireAuth, voiceToken);
tokens.get('/token/tr-worker', requireAuth, workerToken);


==== /src\routes\tokens.js ====

==== src\routes\transfer.js ====
﻿import { Router } from 'express';
import { requireAuth } from 'shared/auth';
import { cold, warm, complete } from '../controllers/transfer.js';

export const transfer = Router();
transfer.post('/transfer/cold', requireAuth, cold);
transfer.post('/transfer/warm', requireAuth, warm);
transfer.post('/transfer/complete', requireAuth, complete);


==== /src\routes\transfer.js ====

==== src\routes\video.js ====
// contact-center/server/src/routes/video.js
import { Router } from 'express';
import { requireAuth } from 'shared/auth';
import { videoController } from '../controllers/video.js';

export const video = Router();

video.get('/video/enabled', videoController.enabled);
video.post('/video/ensure-room', videoController.ensureRoom); // sin auth: lo usa también el webchat público

video.get('/video/token', requireAuth, videoController.tokenAgent);
video.get('/video/token/guest', videoController.tokenGuest);

==== /src\routes\video.js ====

==== src\routes\voice.js ====
import { Router } from 'express';
import { verifyTwilioSignature } from '../middleware/verifyTwilio.js';
import { outbound } from '../controllers/voice.js';

export const voice = Router();
voice.post('/voice/outbound', verifyTwilioSignature, outbound);

==== /src\routes\voice.js ====

==== src\routes\voiceControl.js ====
﻿import { Router } from 'express';
import { requireAuth } from 'shared/auth';
import {
  holdStart,
  holdStop,
  hangupCall,
  recordingStatus,
  recordingStart,
  recordingPause,
  recordingResume,
  recordingStop,
  superviseWhisper,
  superviseBarge
} from '../controllers/voiceControl.js';

export const voiceControl = Router();
voiceControl.post('/voice/hold/start', requireAuth, holdStart);
voiceControl.post('/voice/hold/stop', requireAuth, holdStop);
voiceControl.post('/voice/hangup', requireAuth, hangupCall);
voiceControl.get('/voice/recordings/status', requireAuth, recordingStatus);
voiceControl.post('/voice/recordings/start', requireAuth, recordingStart);
voiceControl.post('/voice/recordings/pause', requireAuth, recordingPause);
voiceControl.post('/voice/recordings/resume', requireAuth, recordingResume);
voiceControl.post('/voice/recordings/stop', requireAuth, recordingStop);
voiceControl.post('/supervise/whisper', requireAuth, superviseWhisper);
voiceControl.post('/supervise/barge', requireAuth, superviseBarge);


==== /src\routes\voiceControl.js ====

==== src\services\crm.js ====
import { crm } from '../lib/crmClient.js';

export const vehicleById = (id) => crm.vehicleById(id);
export const customerById = (id) => crm.customerById(id);
export const vehicleByPlate = (plate) => crm.vehicleByPlate(plate);
export const vehicleByVin = (vin) => crm.vehicleByVin(vin);
export const appointments = (vehicleId) => crm.appointments(vehicleId);
export const createAppointment = (body) => crm.createAppointment(body);
export const finance = (customerId, otpVerified) => crm.finance(customerId, otpVerified);
export const payLink = (customerId) => crm.payLink(customerId);
export const logInteraction = (body) => crm.logInteraction(body);

==== /src\services\crm.js ====

==== src\services\ivr.js ====
import { crm } from '../lib/crmClient.js';

export const findVehicleByVin = (vin) => crm.vehicleByVin(String(vin).toUpperCase());
export const findVehicleByPlate = (plate) => crm.vehicleByPlate(String(plate).toUpperCase());
export const findCustomerByAni = (ani) => crm.customerByAni(String(ani).replace(/\D/g, ''));
export const findVehicleById = (id) => crm.vehicleById(id);
export const findCustomerById = (id) => crm.customerById(id);
export const getAppointments = (vehicleId) => crm.appointments(vehicleId);
export const createAppointment = (data) => crm.createAppointment(data);
export const getRecallsByVin = (vin) => crm.recallsByVin(String(vin).toUpperCase());
export const getFinance = (customerId, otpVerified) => crm.finance(customerId, otpVerified);
export const createPayLink = (customerId) => crm.payLink(customerId);

==== /src\services\ivr.js ====

==== src\services\taskrouter.js ====
﻿﻿import axios from 'axios';
import { rest } from '../twilio.js';
import { serverEnv as env } from 'shared/env';

export const listActivities = () =>
  rest.taskrouter.v1.workspaces(env.workspaceSid).activities.list({ limit: 50 });

export const listWorkerReservations = (workerSid) =>
  rest.taskrouter.v1.workspaces(env.workspaceSid).workers(workerSid).reservations.list({ limit: 50 });

export const fetchTask = (taskSid) =>
  rest.taskrouter.v1.workspaces(env.workspaceSid).tasks(taskSid).fetch();

export const updateTask = (taskSid, payload) =>
  rest.taskrouter.v1.workspaces(env.workspaceSid).tasks(taskSid).update(payload);

export function createTask({ attributes = {}, taskChannel, ...opts } = {}) {
  const attrsObj = typeof attributes === 'string' ? JSON.parse(attributes) : { ...attributes };
  if (!('taskSid' in attrsObj)) attrsObj.taskSid = null;
  const attrs = JSON.stringify(attrsObj);
  const payload = { attributes: attrs, workflowSid: env.workflowSid, ...opts };
  if (taskChannel) payload.taskChannel = taskChannel;
  return rest.taskrouter.v1.workspaces(env.workspaceSid).tasks.create(payload);
}

export const completeTask = (taskSid, reason = 'Conversation closed') =>
  updateTask(taskSid, { assignmentStatus: 'completed', reason });

export const listWorkers = () =>
  rest.taskrouter.v1.workspaces(env.workspaceSid).workers.list({ limit: 200 });

export async function listWorkersWithRetry(retries = 2, delay = 300) {
  let last;
  for (let i = 0; i <= retries; i++) {
    try {
      return await listWorkers();
    } catch (e) {
      last = e; if (i === retries) throw last; await new Promise(r => setTimeout(r, delay));
    }
  }
}

// 🔸 aceptar una reservación (para auto-asignar al agente)
export const acceptReservation = (workerSid, reservationSid) =>
  rest.taskrouter.v1
    .workspaces(env.workspaceSid)
    .workers(workerSid)
    .reservations(reservationSid)
    .update({ reservationStatus: 'accepted' });

const _events = [];
export function pushEvent(type, payload) {
  _events.push({ type, payload, ts: new Date().toISOString() });
  if (_events.length > 500) _events.shift();
}
export const recentEvents = () => _events.slice(-200);
export { axios, env };

==== /src\services\taskrouter.js ====

==== src\services\tokens.js ====
﻿import { buildVoiceToken, buildWorkerToken, rest } from '../twilio.js';
import { serverEnv as env } from 'shared/env';

export const fetchWorker = (workerSid) =>
  rest.taskrouter.v1.workspaces(env.workspaceSid).workers(workerSid).fetch();

export const createVoiceToken = (identity) => buildVoiceToken(identity);
export const createWorkerToken = (workerSid) => buildWorkerToken(workerSid);


==== /src\services\tokens.js ====

==== src\services\transfer.js ====
﻿import { rest } from '../twilio.js';
import { serverEnv as env } from 'shared/env';

export async function waitUntilInProgress(callSid, { tries = 8, delayMs = 250 } = {}) {
  for (let i = 0; i < tries; i++) {
    const c = await rest.calls(callSid).fetch();
    if (c.status === 'in-progress') return c;
    if (['completed', 'canceled', 'failed', 'busy', 'no-answer'].includes(c.status)) {
      const err = new Error(`Call ${callSid} is ${c.status}, cannot redirect`);
      err.code = 'NOT_REDIRECTABLE';
      err.twilioStatus = c.status;
      throw err;
    }
    await new Promise((r) => setTimeout(r, delayMs));
  }
  const c = await rest.calls(callSid).fetch();
  const err = new Error(`Call ${callSid} still ${c.status}, not in-progress`);
  err.code = 'NOT_IN_PROGRESS';
  err.twilioStatus = c.status;
  throw err;
}

export const updateCall = (sid, params) => rest.calls(sid).update(params);
export const createCall = (params) => rest.calls.create(params);
export { env };


==== /src\services\transfer.js ====

==== src\services\voice.js ====
﻿// contact-center/server/src/services/voice.js
import Twilio from 'twilio';
import { serverEnv as env } from 'shared/env';

/**
 * Construye TwiML <Dial> hacia número o <Client>, permitiendo callerIdOverride.
 * Si callerIdOverride no es válido, Twilio usará el callerId por defecto (env.callerId).
 * Se añade answerOnBridge:true para evitar early media/silencio antes de que conteste el destino.
 */
export function buildOutboundTwiml(to, callerIdOverride) {
  const twiml = new Twilio.twiml.VoiceResponse();
  if (!to) {
    twiml.say('Missing destination.');
    return twiml.toString();
  }

  const dial = twiml.dial({
    callerId: callerIdOverride || env.callerId,
    answerOnBridge: true
  });

  if (to.startsWith('client:')) {
    dial.client({}, to.replace('client:', ''));
  } else {
    dial.number({}, to);
  }

  return twiml.toString();
}

==== /src\services\voice.js ====

==== src\services\voiceControl.js ====
﻿import { rest } from '../twilio.js';
import { serverEnv as env } from 'shared/env';

const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
const esc = (s) => String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;');

export function conferenceTwiml(name, { endOnExit = false, beep = false } = {}) {
  return `
<Response>
  <Dial callerId="${esc(env.callerId)}">
    <Conference beep="${beep ? 'true' : 'false'}"
                endConferenceOnExit="${endOnExit ? 'true' : 'false'}">${esc(name)}</Conference>
  </Dial>
</Response>`.trim();
}

export async function waitForConferenceByName(friendlyName, { tries = 60, delayMs = 300 } = {}) {
  for (let i = 0; i < tries; i++) {
    const list = await rest.conferences.list({ friendlyName, status: 'in-progress', limit: 1 });
    if (list && list.length) return list[0];
    await sleep(delayMs);
  }
  throw new Error(`Conference "${friendlyName}" not in-progress`);
}

export async function waitForConferenceBySid(confSid, { tries = 60, delayMs = 300 } = {}) {
  for (let i = 0; i < tries; i++) {
    try {
      const c = await rest.conferences(confSid).fetch();
      if (String(c.status).toLowerCase() === 'in-progress') return c;
    } catch {}
    await sleep(delayMs);
  }
  throw new Error(`Conference ${confSid} not in-progress`);
}

export async function waitForParticipantByCallSid(confSid, callSid, { tries = 60, delayMs = 300 } = {}) {
  for (let i = 0; i < tries; i++) {
    const parts = await rest.conferences(confSid).participants.list({ limit: 50 });
    const match = parts.find((p) => p.callSid === callSid);
    if (match) return match;
    await sleep(delayMs);
  }
  throw new Error(`Participant ${callSid} not found in conference ${confSid}`);
}

export async function waitUntilParticipantConnected(confSid, callSid, { tries = 60, delayMs = 300 } = {}) {
  for (let i = 0; i < tries; i++) {
    try {
      const p = await rest.conferences(confSid).participants(callSid).fetch();
      if (String(p.status).toLowerCase() === 'connected') return p;
    } catch {}
    await sleep(delayMs);
  }
  throw new Error(`Participant ${callSid} not 'connected' in conference ${confSid}`);
}

export async function getConferenceFromTask(taskSid) {
  const task = await rest.taskrouter.v1.workspaces(env.workspaceSid).tasks(taskSid).fetch();
  let attrs = {};
  try { attrs = JSON.parse(task.attributes || '{}'); } catch {}
  const confSid =
    attrs?.conference?.sid ||
    attrs?.conference?.conference_sid ||
    null;
  const customerCallSid =
    attrs?.conference?.participants?.customer ||
    attrs?.customer?.callSid ||
    attrs?.callSid ||
    null;
  const workerCallSid =
    attrs?.conference?.participants?.worker ||
    attrs?.conference?.participants?.agent ||
    attrs?.worker?.callSid ||
    null;
  if (!confSid) return null;
  return { confSid, customerCallSid, workerCallSid };
}

export async function ensureConferenceReadyByName({ confName, customerCallSid, agentCallSid }) {
  const twimlCust = conferenceTwiml(confName, { endOnExit: true, beep: false });
  const twimlAgnt = conferenceTwiml(confName, { endOnExit: false, beep: false });
  try { await rest.calls(customerCallSid).update({ twiml: twimlCust }); } catch {}
  try { await rest.calls(agentCallSid).update({ twiml: twimlAgnt }); } catch {}
  return await waitForConferenceByName(confName);
}

export async function updateHold(confSid, callSidOrLabel, hold, holdUrl) {
  const payload = hold ? { hold: true, holdUrl } : { hold: false };
  let lastErr;
  for (let i = 0; i < 10; i++) {
    try {
      return await rest.conferences(confSid).participants(callSidOrLabel).update(payload);
    } catch (e) {
      lastErr = e;
      await sleep(250);
    }
  }
  throw lastErr;
}

export async function latestRecordingForCall(callSid) {
  const recs = await rest.calls(callSid).recordings.list({ limit: 20 });
  if (!recs || !recs.length) return null;
  return recs.find((r) => r.status === 'in-progress') || recs.find((r) => r.status === 'paused') || recs[0];
}

export { env };
export const createRecording = (callSid) => rest.calls(callSid).recordings.create({});
export const updateRecording = (callSid, recordingSid, params) => rest.calls(callSid).recordings(recordingSid).update(params);
export const createParticipant = (conferenceSid, params) => rest.conferences(conferenceSid).participants.create(params);


==== /src\services\voiceControl.js ====

==== src\twilio.js ====
﻿// contact-center/server/src/twilio.js
import Twilio from 'twilio';
import { serverEnv as env } from 'shared/env';

/* ----------------------------- Helpers ENVs ----------------------------- */
function assertEnv(names, context = 'twilio.js') {
  const missing = names.filter((k) => !env[k]);
  if (missing.length) {
    const list = missing.join(', ');
    throw new Error(`[Twilio] Missing required env(s) for ${context}: ${list}`);
  }
}

/* ------------------------------- REST client ------------------------------- */
/**
 * Requeridos para REST:
 * - TWILIO_ACCOUNT_SID
 * - TWILIO_AUTH_TOKEN
 */
assertEnv(['accountSid', 'authToken'], 'REST client');
export const rest = Twilio(env.accountSid, env.authToken);

/* --------------------------- AccessToken (Voice/Video) --------------------------- */
const { AccessToken } = Twilio.jwt || {};
if (!AccessToken) {
  throw new Error('[Twilio] jwt.AccessToken not available (check twilio SDK version)');
}
const { VoiceGrant, VideoGrant } = AccessToken;

/* --------------------------- Voice AccessToken --------------------------- */
export function buildVoiceToken(identity) {
  if (!identity) throw new Error('[VoiceToken] missing identity');

  // ENVs críticos para Voice token
  assertEnv(['accountSid', 'apiKey', 'apiSecret'], 'Voice AccessToken');

  // IMPORTANTE: Voice identity NO debe incluir "client:".
  // Si llega "client:agent:42" en claims → usar "agent:42".
  const rawIdentity = String(identity);
  const identityForVoice = rawIdentity.startsWith('client:')
    ? rawIdentity.slice('client:'.length)
    : rawIdentity;

  const token = new AccessToken(
    env.accountSid,
    env.apiKey,
    env.apiSecret,
    { identity: identityForVoice, ttl: 3600 } // 1h
  );

  const grant = new VoiceGrant({
    outgoingApplicationSid: env.twimlAppSid || undefined,
    incomingAllow: true,
  });

  token.addGrant(grant);
  return token.toJwt();
}

/* --------------------- TaskRouter Worker Capability --------------------- */
const TR = (Twilio.jwt && Twilio.jwt.taskrouter) || {};
const TaskRouterCapability = TR.TaskRouterCapability || TR;
const Policy = (TaskRouterCapability && TaskRouterCapability.Policy) || TR.Policy;

if (!TaskRouterCapability) {
  throw new Error('[Twilio] TaskRouterCapability not available (check twilio SDK version)');
}
if (!Policy) {
  throw new Error('[Twilio] TaskRouter Policy class not available (check twilio SDK version)');
}

function buildPolicy({ url, method, allow }) {
  return new Policy({
    url,
    method,
    allow,
    queryFilter: {},
    postFilter: {},
  });
}

export function buildWorkerToken(workerSid) {
  if (!workerSid) throw new Error('[WorkerToken] missing workerSid');

  // ENVs críticos para Worker capability
  assertEnv(['workspaceSid', 'accountSid', 'authToken'], 'TaskRouter Worker Capability');

  const workspaceSid = env.workspaceSid;
  const accountSid = env.accountSid;
  const authToken = env.authToken;

  const capability = new TaskRouterCapability({
    accountSid,
    authToken,
    workspaceSid,
    channelId: workerSid,
  });

  // Base URLs
  const TR_BASE = 'https://taskrouter.twilio.com/v1';
  const EB_BASE = 'https://event-bridge.twilio.com/v1/wschannels';

  // Worker resources
  const workerUrl = `${TR_BASE}/Workspaces/${workspaceSid}/Workers/${workerSid}`;
  const workerSubresources = `${workerUrl}/**`;

  // Tasks (SDK lee Task y Reservations de esa Task) → evitar 403 Event Bridge
  const tasksUrlAll = `${TR_BASE}/Workspaces/${workspaceSid}/Tasks/**`;

  // Activities (para UI / estados)
  const activitiesUrl = `${TR_BASE}/Workspaces/${workspaceSid}/Activities`;
  const activitiesAllUrl = `${activitiesUrl}/**`;

  // Event Bridge channel + messages (GET/POST)
  const ebChannelUrl = `${EB_BASE}/${accountSid}/${workerSid}`;
  const ebMessagesUrl = `${ebChannelUrl}/messages`;

  const policies = [
    // Worker & subresources
    buildPolicy({ url: workerUrl, method: 'GET', allow: true }),
    buildPolicy({ url: workerSubresources, method: 'GET', allow: true }),
    buildPolicy({ url: workerUrl, method: 'POST', allow: true }),
    buildPolicy({ url: workerSubresources, method: 'POST', allow: true }),

    // Tasks (NECESARIO para que el SDK consulte Task/Reservations sin 403)
    buildPolicy({ url: tasksUrlAll, method: 'GET', allow: true }),
    buildPolicy({ url: tasksUrlAll, method: 'POST', allow: true }),

    // Activities (opcional pero útil para UI)
    buildPolicy({ url: activitiesUrl, method: 'GET', allow: true }),
    buildPolicy({ url: activitiesAllUrl, method: 'GET', allow: true }),

    // Event Bridge channel + messages (GET/POST)
    buildPolicy({ url: ebChannelUrl, method: 'GET', allow: true }),
    buildPolicy({ url: ebChannelUrl, method: 'POST', allow: true }),
    buildPolicy({ url: ebMessagesUrl, method: 'GET', allow: true }),
    buildPolicy({ url: ebMessagesUrl, method: 'POST', allow: true }),
  ];

  policies.forEach((p) => capability.addPolicy(p));

  // Generar JWT (SDKs antiguos usan generate(); modernos usan toJwt())
  if (typeof capability.generate === 'function') return capability.generate(3600); // 1h
  if (typeof capability.toJwt === 'function') return capability.toJwt();

  throw new Error('[TaskRouterCapability] neither generate() nor toJwt() available');
}

/* --------------------------- Video AccessToken --------------------------- */
export function buildVideoToken(identity, roomName) {
  if (!identity) throw new Error('[VideoToken] missing identity');
  assertEnv(['accountSid', 'apiKey', 'apiSecret'], 'Video AccessToken');

  // Igual que Voice: identidad sin "client:"
  const raw = String(identity);
  const clean = raw.startsWith('client:') ? raw.slice('client:'.length) : raw;

  const token = new AccessToken(
    env.accountSid,
    env.apiKey,
    env.apiSecret,
    { identity: clean, ttl: 3600 } // 1h
  );

  const grant = roomName ? new VideoGrant({ room: roomName }) : new VideoGrant();
  token.addGrant(grant);
  return token.toJwt();
}

==== /src\twilio.js ====

==== src\validateEnv.js ====
﻿import { serverEnv as env } from 'shared/env';
export function validateEnv() {
  const required = [
    'accountSid','authToken','apiKey','apiSecret',
    'workspaceSid','workflowSid','wrapActivitySid',
    'callerId','conversationsServiceSid'
  ];
  const missing = required.filter(k => !env[k]);
  if (missing.length) {
    console.warn('[ENV WARNING] Missing:', missing.join(', '));
  }
}


==== /src\validateEnv.js ====

==== test\auth.test.js ====
import test from 'node:test';
import assert from 'node:assert/strict';
import jwt from 'jsonwebtoken';

import { signAgentToken, requireAuth } from 'shared/auth';
import { serverEnv as env } from 'shared/env';

function createRes() {
  const res = {};
  res.status = (code) => { res.statusCode = code; return res; };
  res.json = (body) => { res.body = body; return res; };
  return res;
}

test('accepts tokens signed with HS256', () => {
  const token = signAgentToken('user', 'WS123', 'alice');
  const req = { headers: { cookie: `${env.accessTokenName}=${token}` } };
  const res = createRes();
  let called = false;

  requireAuth(req, res, () => { called = true; });

  assert.equal(called, true);
  assert.equal(res.statusCode, undefined);
});

test('rejects tokens signed with non-HS256 algorithms', () => {
  const token = jwt.sign({ sub: 'user' }, env.jwtSecret, { algorithm: 'HS512' });
  const req = { headers: { cookie: `${env.accessTokenName}=${token}` } };
  const res = createRes();
  let called = false;

  requireAuth(req, res, () => { called = true; });

  assert.equal(called, false);
  assert.equal(res.statusCode, 401);
  assert.deepEqual(res.body, { error: 'invalid token' });
});

==== /test\auth.test.js ====

